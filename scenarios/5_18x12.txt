
typedef struct { int r; int c; } pos_t;
const int GRID_LENGTH = 18;
const int GRID_HEIGHT = 12;
const int N_EXITS = 14;
const int N_FIRES = 48;
const int N_CIVILIANS = 10;
const int N_FIRST_RESPONDERS = 3;
const int N_DRONES = 4;
const int T_ZR = 7;                      // Time that a Zero Responder needs to help someone
const int T_FR = 3;                      // Time that a First Responder needs to help someone
const int T_V = 10;                       // Time before a civilian is supposed to die
const int N_V = 2;                       // Drones' visibility range
const int MAX_TRAJ = 22;                   // Max trajectory length

// Grid layout

const pos_t OUT_OF_MAP = { -1, -1 };
int grid[GRID_LENGTH][GRID_HEIGHT] = {
  {2, 0, 0, 2, 1, 0, 0, 0, 0, 0, 1, 1},
  {2, 2, 2, 2, 0, 3, 0, 0, 0, 0, 0, 0},
  {2, 2, 2, 2, 0, 0, 3, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {1, 0, 3, 8, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 3, 0, 3, 0, 0, 8, 0, 0, 1},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
  {3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
  {0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 2, 2},
  {1, 0, 3, 8, 2, 2, 0, 0, 0, 0, 2, 0},
  {1, 0, 0, 0, 2, 2, 0, 0, 0, 0, 2, 2},
  {0, 3, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0},
  {0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0},
  {3, 0, 0, 0, 0, 3, 2, 2, 2, 2, 0, 1},
  {2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 1},
  {2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 1},
  {0, 2, 2, 2, 0, 0, 1, 0, 0, 0, 0, 1}
};

// Global arrays

pos_t drone_trajectories[N_DRONES][MAX_TRAJ] = {
  {{2, 0}, {2, 1}, {2, 2}, {2, 3}, {2, 4}, {2, 5}, {2, 6}, {2, 7}, {2, 8}, {2, 9}, {2, 10}, {2, 11}, {2, 10}, {2, 9}, {2, 8}, {2, 7}, {2, 6}, {2, 5}, {2, 4}, {2, 3}, {2, 2}, {2, 1}},
  {{6, 0}, {6, 1}, {6, 2}, {6, 3}, {6, 4}, {6, 5}, {6, 6}, {6, 7}, {6, 8}, {6, 9}, {6, 10}, {6, 11}, {6, 10}, {6, 9}, {6, 8}, {6, 7}, {6, 6}, {6, 5}, {6, 4}, {6, 3}, {6, 2}, {6, 1}},
  {{11, 0}, {11, 1}, {11, 2}, {11, 3}, {11, 4}, {11, 5}, {11, 6}, {11, 7}, {11, 8}, {11, 9}, {11, 10}, {11, 11}, {11, 10}, {11, 9}, {11, 8}, {11, 7}, {11, 6}, {11, 5}, {11, 4}, {11, 3}, {11, 2}, {11, 1}},
  {{15, 0}, {15, 1}, {15, 2}, {15, 3}, {15, 4}, {15, 5}, {15, 6}, {15, 7}, {15, 8}, {15, 9}, {15, 10}, {15, 11}, {15, 10}, {15, 9}, {15, 8}, {15, 7}, {15, 6}, {15, 5}, {15, 4}, {15, 3}, {15, 2}, {15, 1}}
};
int drone_traj_lengths[N_DRONES] = {22, 22, 22, 22};

// DRONE DECISION POLICIES
const int ALWAYS_ZR = 0;      // Always call the zero responder nearby
const int ALWAYS_FR = 1;      // Always call the closer first responder if possible (at least one is free)
const int MIN_TIME = 2;       // Call zr or fr based on their total helping time            

// CIVILIAN/FIRST RESPONDER MOVING POLICY
const int CLOSER_EXIT = 0;
const int RANDOM = 1;
const int FIRES = 2; 

// SET POLICIES
int drone_decision_policy = MIN_TIME;
int fr_movement_policy = FIRES;
int civ_moving_policy = CLOSER_EXIT;

// Global variables
int casualties = 0;
int saved = 0;
// TODO: gestire queste variabili e capire come proporzionarle
// Const for model checking
const int N_perc = 80;                    // (N% = N_save/N_CIVILIANS) percentage of all civilians to reach a safe state
const int T_scs = 5;                     // Time to check properties
clock total_time;

//*************************************************************************************************************************************************************************************************************

// Global types
typedef int [0, N_DRONES-1] dr_t;
typedef int [0, N_FIRST_RESPONDERS-1] fr_t;
typedef int [0, N_CIVILIANS-1] civ_t;

// Map constants
const int OUTSIDE      = -1;             // dead or saved
const int NONE         =  0;             
const int EXIT         =  1;             // Exit
const int FIRE         =  2;             // Fire
const int SURVIVOR     =  3;             // Survivor (civilian not in danger)
const int ZERO_R       =  4;             // Zero Responder 
const int NEED_ASSIST  =  5;             // in danger, Civilian in danger in need for assistance
const int ASSISTED     =  6;             // Civilian assisted
const int CONTACTING   =  7;             // busy Zero responder, survivor busy calling a first responder/waiting for him to rescue someone in danger
const int FIRST_R      =  8;             // First Responder not busy
const int FIRST_R_BUSY_CALLED =  9;      // First Responder busy helping someone called by a survivor
const int FIRST_R_BUSY_NEAR_DANGER =  10;// First Responder busy helping someone near danger

const int MAX_INT =  32767; //from doc


// Channels
broadcast chan init_done;
chan helping[N_CIVILIANS];
urgent chan FR_help_req[N_FIRST_RESPONDERS];
broadcast chan saved_by_FR[N_CIVILIANS];
broadcast chan saved_by_ZR[N_CIVILIANS];
broadcast chan civ_dead[N_CIVILIANS]; 
urgent chan call_zero_resp[N_CIVILIANS];
urgent chan call_first_resp[N_CIVILIANS];

// Global arrays (built by initializer)
pos_t exits[N_EXITS];
pos_t fires[N_FIRES];
pos_t pos_FRs[N_FIRST_RESPONDERS];
pos_t pos_civilians[N_CIVILIANS];

// Exits, Humans, Drones can have arbitrary positions.
const int STEP_TIME = 1;                 // Time to step
pos_t pos_to_save = OUT_OF_MAP;
int caller_id = -1;
// TODO: cancellare se non modifichiamo step RANDOM
int directions[8][2] = {
        {1, 0},   // Move down
        {-1, 0},  // Move up
        {0, -1},  // Move left
        {0, 1},   // Move right
        {1, -1},  // Move down-left
        {1, 1},   // Move down-right
        {-1, -1}, // Move up-left
        {-1, 1}   // Move up-right
};

/**************** GLOBAL UTILITY FUNCTIONS ****************/

/*
 * Get the value of a cell of the map given its pos_t coordinates.
 */
int cell(pos_t p) {
    if (p.r >= 0 && p.r < GRID_LENGTH && p.c >= 0 && p.c < GRID_HEIGHT){
        return grid[p.r][p.c];
    } else {
        return OUTSIDE;
    }
}

/*
 * Get the value of a cell of the map given its int coordinates.
 */
int cell_int(int x, int y) {
    if (x >= 0 && x < GRID_LENGTH && y >= 0 && y < GRID_HEIGHT){
        return grid[x][y];
    } else {
        return OUTSIDE;
    }
}

/*
 * Compute max between two integers.
 */ 
int max(int a, int b){
    return a >= b ? a : b;
}


/*
 * Compute distance from two positions in the grid (diagonal moves allowed).
 */
int dist(pos_t src, pos_t dest){
    int x_dist = abs(dest.r - src.r);
    int y_dist = abs(dest.c - src.c);
    return max(x_dist, y_dist) - 1;
}

/*
 * Compute distance from two positions in the grid (NO diagonal moves allowed).
 */
/*
int dist_man(pos_t src, pos_t dest){
    int x_dist = abs(dest.r - src.r);
    int y_dist = abs(dest.c - src.c);
    return x_dist + y_dist;
}
*/

/*
 * Move civilian from src to dest in the map (when calling the function cell(src) must be SURVIVOR)
 */ 
void move_civ(pos_t src, pos_t dest){
    grid[src.r][src.c] = NONE;
    grid[dest.r][dest.c] = SURVIVOR;
}

/*
 * Move first responder from src to dest in the map (when calling the function cell(src) must be FIRST_R)
 */ 
void move_fr(pos_t src, pos_t dest){
    grid[src.r][src.c] = NONE;
    grid[dest.r][dest.c] = FIRST_R;
}

/*
 * Retrieve index of a civilian from its position
 */
int get_civ_idx(pos_t pos){
    int i;
    for(i = 0; i < N_CIVILIANS; i++){
        if(pos_civilians[i] == pos) return i;
    }
    return -1;
}

/*
 * Get the next cell to go to reach the objective
 */
pos_t getNextCellToGoTo(pos_t pos1, pos_t pos2){
    int x_move, y_move;
    pos_t ret_pos;
    if(pos1.r > pos2.r){
        y_move = -1;
    } else if(pos1.r == pos2.r){
        y_move = 0; // No vertical movement
    } else{
        y_move = 1;
    }
    
    if(pos1.c > pos2.c){
        x_move = -1;
    } else if(pos1.c == pos2.c){
        x_move = 0; // No horizontal movement
    } else{
        x_move = 1;
    }

    ret_pos.r = pos1.r + y_move;
    ret_pos.c = pos1.c + x_move;

    return ret_pos;
}

/*
 * Check if cell is free
 */
bool isCellFree(pos_t p) {
    if (cell(p) == NONE){
        return true;
    }else{
        return false;
    }
}