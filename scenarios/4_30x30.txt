typedef struct { int r; int c; } pos_t;
const int GRID_LENGTH = 30;
const int GRID_HEIGHT = 30;
const int N_EXITS = 20;
const int N_FIRES = 150;
const int N_CIVILIANS = 8;
const int N_FIRST_RESPONDERS = 3;
const int N_DRONES = 6;
const int T_ZR = 10;                      // Time that a Zero Responder needs to help someone
const int T_FR = 5;                      // Time that a First Responder needs to help someone
const int T_V = 20;                       // Time before a civilian is supposed to die
const int N_V = 2;                       // Drones' visibility range
const int MAX_TRAJ = 58;                   // Max trajectory length

// Grid layout

const pos_t OUT_OF_MAP = { -1, -1 };
int grid[GRID_LENGTH][GRID_HEIGHT] = {
  {0, 0, 0, 3, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 2, 2},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 2, 2},
  {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2},
  {1, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 2, 2},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 2},
  {0, 2, 0, 2, 2, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
  {2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
  {2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
  {2, 2, 2, 2, 2, 2, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {2, 2, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
  {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
  {8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
  {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 0},
  {1, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 2, 2, 2, 0, 0},
  {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 2, 0},
  {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 0, 0}
};

// Global arrays

pos_t drone_trajectories[N_DRONES][MAX_TRAJ] = {
  {{2, 0}, {2, 1}, {2, 2}, {2, 3}, {2, 4}, {2, 5}, {2, 6}, {2, 7}, {2, 8}, {2, 9}, {2, 10}, {2, 11}, {2, 12}, {2, 13}, {2, 14}, {2, 15}, {2, 16}, {2, 17}, {2, 18}, {2, 19}, {2, 20}, {2, 21}, {2, 22}, {2, 23}, {2, 24}, {2, 25}, {2, 26}, {2, 27}, {2, 28}, {2, 29}, {2, 28}, {2, 27}, {2, 26}, {2, 25}, {2, 24}, {2, 23}, {2, 22}, {2, 21}, {2, 20}, {2, 19}, {2, 18}, {2, 17}, {2, 16}, {2, 15}, {2, 14}, {2, 13}, {2, 12}, {2, 11}, {2, 10}, {2, 9}, {2, 8}, {2, 7}, {2, 6}, {2, 5}, {2, 4}, {2, 3}, {2, 2}, {2, 1}},
  {{7, 0}, {7, 1}, {7, 2}, {7, 3}, {7, 4}, {7, 5}, {7, 6}, {7, 7}, {7, 8}, {7, 9}, {7, 10}, {7, 11}, {7, 12}, {7, 13}, {7, 14}, {7, 15}, {7, 16}, {7, 17}, {7, 18}, {7, 19}, {7, 20}, {7, 21}, {7, 22}, {7, 23}, {7, 24}, {7, 25}, {7, 26}, {7, 27}, {7, 28}, {7, 29}, {7, 28}, {7, 27}, {7, 26}, {7, 25}, {7, 24}, {7, 23}, {7, 22}, {7, 21}, {7, 20}, {7, 19}, {7, 18}, {7, 17}, {7, 16}, {7, 15}, {7, 14}, {7, 13}, {7, 12}, {7, 11}, {7, 10}, {7, 9}, {7, 8}, {7, 7}, {7, 6}, {7, 5}, {7, 4}, {7, 3}, {7, 2}, {7, 1}},
  {{12, 0}, {12, 1}, {12, 2}, {12, 3}, {12, 4}, {12, 5}, {12, 6}, {12, 7}, {12, 8}, {12, 9}, {12, 10}, {12, 11}, {12, 12}, {12, 13}, {12, 14}, {12, 15}, {12, 16}, {12, 17}, {12, 18}, {12, 19}, {12, 20}, {12, 21}, {12, 22}, {12, 23}, {12, 24}, {12, 25}, {12, 26}, {12, 27}, {12, 28}, {12, 29}, {12, 28}, {12, 27}, {12, 26}, {12, 25}, {12, 24}, {12, 23}, {12, 22}, {12, 21}, {12, 20}, {12, 19}, {12, 18}, {12, 17}, {12, 16}, {12, 15}, {12, 14}, {12, 13}, {12, 12}, {12, 11}, {12, 10}, {12, 9}, {12, 8}, {12, 7}, {12, 6}, {12, 5}, {12, 4}, {12, 3}, {12, 2}, {12, 1}},
  {{17, 0}, {17, 1}, {17, 2}, {17, 3}, {17, 4}, {17, 5}, {17, 6}, {17, 7}, {17, 8}, {17, 9}, {17, 10}, {17, 11}, {17, 12}, {17, 13}, {17, 14}, {17, 15}, {17, 16}, {17, 17}, {17, 18}, {17, 19}, {17, 20}, {17, 21}, {17, 22}, {17, 23}, {17, 24}, {17, 25}, {17, 26}, {17, 27}, {17, 28}, {17, 29}, {17, 28}, {17, 27}, {17, 26}, {17, 25}, {17, 24}, {17, 23}, {17, 22}, {17, 21}, {17, 20}, {17, 19}, {17, 18}, {17, 17}, {17, 16}, {17, 15}, {17, 14}, {17, 13}, {17, 12}, {17, 11}, {17, 10}, {17, 9}, {17, 8}, {17, 7}, {17, 6}, {17, 5}, {17, 4}, {17, 3}, {17, 2}, {17, 1}},
  {{22, 0}, {22, 1}, {22, 2}, {22, 3}, {22, 4}, {22, 5}, {22, 6}, {22, 7}, {22, 8}, {22, 9}, {22, 10}, {22, 11}, {22, 12}, {22, 13}, {22, 14}, {22, 15}, {22, 16}, {22, 17}, {22, 18}, {22, 19}, {22, 20}, {22, 21}, {22, 22}, {22, 23}, {22, 24}, {22, 25}, {22, 26}, {22, 27}, {22, 28}, {22, 29}, {22, 28}, {22, 27}, {22, 26}, {22, 25}, {22, 24}, {22, 23}, {22, 22}, {22, 21}, {22, 20}, {22, 19}, {22, 18}, {22, 17}, {22, 16}, {22, 15}, {22, 14}, {22, 13}, {22, 12}, {22, 11}, {22, 10}, {22, 9}, {22, 8}, {22, 7}, {22, 6}, {22, 5}, {22, 4}, {22, 3}, {22, 2}, {22, 1}},
  {{27, 0}, {27, 1}, {27, 2}, {27, 3}, {27, 4}, {27, 5}, {27, 6}, {27, 7}, {27, 8}, {27, 9}, {27, 10}, {27, 11}, {27, 12}, {27, 13}, {27, 14}, {27, 15}, {27, 16}, {27, 17}, {27, 18}, {27, 19}, {27, 20}, {27, 21}, {27, 22}, {27, 23}, {27, 24}, {27, 25}, {27, 26}, {27, 27}, {27, 28}, {27, 29}, {27, 28}, {27, 27}, {27, 26}, {27, 25}, {27, 24}, {27, 23}, {27, 22}, {27, 21}, {27, 20}, {27, 19}, {27, 18}, {27, 17}, {27, 16}, {27, 15}, {27, 14}, {27, 13}, {27, 12}, {27, 11}, {27, 10}, {27, 9}, {27, 8}, {27, 7}, {27, 6}, {27, 5}, {27, 4}, {27, 3}, {27, 2}, {27, 1}}
};
int drone_traj_lengths[N_DRONES] = {58, 58, 58, 58, 58, 58};

// DRONE DECISION POLICIES
const int ALWAYS_ZR = 0;      // Always call the zero responder nearby
const int ALWAYS_FR = 1;      // Always call the closer first responder if possible (at least one is free)
const int MIN_TIME = 2;       // Call zr or fr based on their total helping time            

// CIVILIAN/FIRST RESPONDER MOVING POLICY
const int CLOSER_EXIT = 0;
const int RANDOM = 1;
const int FIRES = 2; 

// SET POLICIES
int drone_decision_policy = ALWAYS_ZR    ;
int fr_movement_policy = FIRES;
int civ_moving_policy = CLOSER_EXIT;

// Global variables
int casualties = 0;
int saved = 0;
// TODO: gestire queste variabili e capire come proporzionarle
// Const for model checking
const int N_perc = 100;                    // (N% = N_save/N_CIVILIANS) percentage of all civilians to reach a safe state
const int T_scs = 15;                     // Time to check properties
clock total_time;

//*************************************************************************************************************************************************************************************************************

// Global types
typedef int [0, N_DRONES-1] dr_t;
typedef int [0, N_FIRST_RESPONDERS-1] fr_t;
typedef int [0, N_CIVILIANS-1] civ_t;

// Map constants
const int OUTSIDE      = -1;             // dead or saved
const int NONE         =  0;             
const int EXIT         =  1;             // Exit
const int FIRE         =  2;             // Fire
const int SURVIVOR     =  3;             // Survivor (civilian not in danger)
const int ZERO_R       =  4;             // Zero Responder 
const int NEED_ASSIST  =  5;             // in danger, Civilian in danger in need for assistance
const int ASSISTED     =  6;             // Civilian assisted
const int CONTACTING   =  7;             // busy Zero responder, survivor busy calling a first responder/waiting for him to rescue someone in danger
const int FIRST_R      =  8;             // First Responder not busy
const int FIRST_R_BUSY_CALLED =  9;      // First Responder busy helping someone called by a survivor
const int FIRST_R_BUSY_NEAR_DANGER =  10;// First Responder busy helping someone near danger

const int MAX_INT =  32767; //from doc


// Channels
broadcast chan init_done;
chan helping[N_CIVILIANS];
urgent chan FR_help_req[N_FIRST_RESPONDERS];
broadcast chan saved_by_FR[N_CIVILIANS];
broadcast chan saved_by_ZR[N_CIVILIANS];
broadcast chan civ_dead[N_CIVILIANS]; 
urgent chan call_zero_resp[N_CIVILIANS];
urgent chan call_first_resp[N_CIVILIANS];

// Global arrays (built by initializer)
pos_t exits[N_EXITS];
pos_t fires[N_FIRES];
pos_t pos_FRs[N_FIRST_RESPONDERS];
pos_t pos_civilians[N_CIVILIANS];

// Exits, Humans, Drones can have arbitrary positions.
const int STEP_TIME = 1;                 // Time to step
pos_t pos_to_save = OUT_OF_MAP;
int caller_id = -1;
// TODO: cancellare se non modifichiamo step RANDOM
int directions[8][2] = {
        {1, 0},   // Move down
        {-1, 0},  // Move up
        {0, -1},  // Move left
        {0, 1},   // Move right
        {1, -1},  // Move down-left
        {1, 1},   // Move down-right
        {-1, -1}, // Move up-left
        {-1, 1}   // Move up-right
};

/**************** GLOBAL UTILITY FUNCTIONS ****************/

/*
 * Get the value of a cell of the map given its pos_t coordinates.
 */
int cell(pos_t p) {
    if (p.r >= 0 && p.r < GRID_LENGTH && p.c >= 0 && p.c < GRID_HEIGHT){
        return grid[p.r][p.c];
    } else {
        return OUTSIDE;
    }
}

/*
 * Get the value of a cell of the map given its int coordinates.
 */
int cell_int(int x, int y) {
    if (x >= 0 && x < GRID_LENGTH && y >= 0 && y < GRID_HEIGHT){
        return grid[x][y];
    } else {
        return OUTSIDE;
    }
}

/*
 * Compute max between two integers.
 */ 
int max(int a, int b){
    return a >= b ? a : b;
}


/*
 * Compute distance from two positions in the grid (diagonal moves allowed).
 */
int dist(pos_t src, pos_t dest){
    int x_dist = abs(dest.r - src.r);
    int y_dist = abs(dest.c - src.c);
    return max(x_dist, y_dist) - 1;
}

/*
 * Compute distance from two positions in the grid (NO diagonal moves allowed).
 */
/*
int dist_man(pos_t src, pos_t dest){
    int x_dist = abs(dest.r - src.r);
    int y_dist = abs(dest.c - src.c);
    return x_dist + y_dist;
}
*/

/*
 * Move civilian from src to dest in the map (when calling the function cell(src) must be SURVIVOR)
 */ 
void move_civ(pos_t src, pos_t dest){
    grid[src.r][src.c] = NONE;
    grid[dest.r][dest.c] = SURVIVOR;
}

/*
 * Move first responder from src to dest in the map (when calling the function cell(src) must be FIRST_R)
 */ 
void move_fr(pos_t src, pos_t dest){
    grid[src.r][src.c] = NONE;
    grid[dest.r][dest.c] = FIRST_R;
}

/*
 * Retrieve index of a civilian from its position
 */
int get_civ_idx(pos_t pos){
    int i;
    for(i = 0; i < N_CIVILIANS; i++){
        if(pos_civilians[i] == pos) return i;
    }
    return -1;
}

/*
 * Get the next cell to go to reach the objective
 */
pos_t getNextCellToGoTo(pos_t pos1, pos_t pos2){
    int x_move, y_move;
    pos_t ret_pos;
    if(pos1.r > pos2.r){
        y_move = -1;
    } else if(pos1.r == pos2.r){
        y_move = 0; // No vertical movement
    } else{
        y_move = 1;
    }
    
    if(pos1.c > pos2.c){
        x_move = -1;
    } else if(pos1.c == pos2.c){
        x_move = 0; // No horizontal movement
    } else{
        x_move = 1;
    }

    ret_pos.r = pos1.r + y_move;
    ret_pos.c = pos1.c + x_move;

    return ret_pos;
}

/*
 * Check if cell is free
 */
bool isCellFree(pos_t p) {
    if (cell(p) == NONE){
        return true;
    }else{
        return false;
    }
}