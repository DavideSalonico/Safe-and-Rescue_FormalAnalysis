<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.6//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_6.dtd'>
<nta>
	<declaration>
typedef struct { int r; int c; } pos_t;

// Place global declarations here.
const int GRID_LENGTH = 10;
const int GRID_HEIGHT = 10;
const int N_EXITS = 6;
const int N_FIRES = 15;
const int N_DRONES = 2;
const int N_CIVILIANS = 6;
const int N_FIRST_RESPONDERS = 2;
const int T_ZR = 4;                      // Time that a Zero Responder needs to help someone
const int T_FR = 4;                      // Time that a First Responder needs to help someone
const int T_V = 10;                      // Time before a civilian is supposed to die
const int N_V = 2;                       // Drones' visibility range
const int MAX_TRAJ = 8;                  // Max trajectory length

const pos_t OUT_OF_MAP = {-1, -1};       // Position to declare someone has exited the map (either dead or alive)

// Grid layout
int grid[GRID_LENGTH][GRID_HEIGHT] = {{0, 0, 1, 1, 1, 2, 2, 0, 0, 0},
                                      {0, 0, 0, 0, 0, 2, 2, 0, 0, 0},
                                      {0, 0, 0, 0, 0, 2, 2, 0, 0, 0},
                                      {0, 0, 8, 0, 0, 5, 0, 0, 0, 0},
                                      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                      {1, 0, 0, 3, 0, 0, 3, 0, 0, 3},
                                      {1, 0, 0, 0, 3, 0, 8, 0, 0, 0},
                                      {1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                      {0, 0, 2, 2, 0, 0, 0, 0, 0, 0},
                                      {0, 0, 2, 2, 2, 2, 0, 2, 5, 0}};

pos_t drone_trajectories[N_DRONES][MAX_TRAJ] = {{{4, 6}, {3, 6}, {3, 5}, {4, 5}, {4, 6}, {3, 6}, {3, 5}, {4, 5}},
                                                {{6, 3}, {6, 4}, {6, 5}, {5, 5}, {5, 4}, {4, 4}, OUT_OF_MAP, OUT_OF_MAP}};
int drone_traj_lengths[N_DRONES] = {4, 6};

typedef int ddp_t;              // DRONE DECISION POLICY
const ddp_t ALWAYS_ZR = 0;      // Always call the zero responder nearby
const ddp_t ALWAYS_FR = 1;      // Always call the closer first responder if possible (at least one is free)
const ddp_t MIN_TIME = 2;       // Call zr or fr based on their total helping time

typedef int cmp_t;             

typedef int movement_policy_t;            //CIVILIAN/FIRST RESPONDER MOVING POLICY
const movement_policy_t CLOSER_EXIT = 0;
const movement_policy_t RANDOM = 1; 

ddp_t drone_decision_policy = MIN_TIME;
movement_policy_t fr_movement_policy = RANDOM;
movement_policy_t civ_moving_policy = CLOSER_EXIT;

// TODO: gestire queste variabili e capire come proporzionarle
// Const for model checking
const int N_save = 1;                    // (N% = N_save/N_CIVILIANS) percentage of all civilians to reach a safe state
const int T_scs = 20;                     // Time to check properties
clock total_time;

// Stochastic Version (Probability weight, max is 10000)
const int P_listen = 9000;
const int P_ignore = 10000 - P_listen;
const int P_fail = 1000;
const int P_succ = 10000 - P_fail;

// Global types
typedef int [0, N_DRONES-1] dr_t;
typedef int [0, N_FIRST_RESPONDERS-1] fr_t;
typedef int [0, N_CIVILIANS-1] civ_t;

// Map constants
const int OUTSIDE      = -1;             // dead or saved
const int NONE         =  0;             
const int EXIT         =  1;             // Exit
const int FIRE         =  2;             // Fire
const int SURVIVOR     =  3;             // Survivor (civilian not in danger)
const int ZERO_R       =  4;             // Zero Responder 
const int NEED_ASSIST  =  5;             // in danger, Civilian in danger in need for assistance
const int ASSISTED     =  6;             // Civilian assisted
const int CONTACTING   =  7;             // busy Zero responder, survivor busy calling a first responder/waiting for him to rescue someone in danger
const int FIRST_R      =  8;             // First Responder not busy
const int FIRST_R_BUSY_CALLED =  9;      // First Responder busy helping someone called by a survivor
const int FIRST_R_BUSY_NEAR_DANGER =  10;// First Responder busy helping someone near danger

const int MAX_INT =  32767; //from doc

// Channels
broadcast chan init_done;
broadcast chan helping[N_CIVILIANS];
broadcast chan FR_help_req[N_FIRST_RESPONDERS]; //
broadcast chan saved_by_FR[N_CIVILIANS];
broadcast chan saved_by_ZR[N_CIVILIANS];
broadcast chan civ_dead[N_CIVILIANS]; 
broadcast chan call_zero_resp[N_CIVILIANS]; //
broadcast chan call_first_resp[N_CIVILIANS]; //


// Global variables
int casualties = 0;
int saved = 0;

// Global arrays
pos_t exits[N_EXITS];
pos_t fires[N_FIRES];
pos_t pos_FRs[N_FIRST_RESPONDERS];
pos_t pos_civilians[N_CIVILIANS];

// Exits, Humans, Drones can have arbitrary positions.
// TODO: check if just a position is ok or we need an array
const int STEP_TIME = 1;                 // Time to step
pos_t pos_to_save = OUT_OF_MAP;
int caller_id = -1;
int directions[8][2] = {
        {1, 0},   // Move down
        {-1, 0},  // Move up
        {0, -1},  // Move left
        {0, 1},   // Move right
        {1, -1},  // Move down-left
        {1, 1},   // Move down-right
        {-1, -1}, // Move up-left
        {-1, 1}   // Move up-right
};

/* GLOBAL UTILITY FUNCTIONS ****************/

/*
 * Get the value of a cell of the map given its pos_t coordinates.
 */
int cell(pos_t p) {
    if (p.r &gt;= 0 &amp;&amp; p.r &lt; GRID_LENGTH &amp;&amp; p.c &gt;= 0 &amp;&amp; p.c &lt; GRID_HEIGHT){
        return grid[p.r][p.c];
    } else {
        return OUTSIDE;
    }
}

/*
 * Get the value of a cell of the map given its int coordinates.
 */
int cell_int(int x, int y) {
    if (x &gt;= 0 &amp;&amp; x &lt; GRID_LENGTH &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; GRID_HEIGHT){
        return grid[x][y];
    } else {
        return OUTSIDE;
    }
}

/*
 * Compute max between two integers.
 */ 
int max(int a, int b){
    return a &gt;= b ? a : b;
}


/*
 * Compute distance from two positions in the grid (diagonal moves allowed).
 */
int dist(pos_t src, pos_t dest){
    int x_dist = abs(dest.r - src.r);
    int y_dist = abs(dest.c - src.c);
    return max(x_dist, y_dist) - 1;
}

/*
 * Compute distance from two positions in the grid (NO diagonal moves allowed).
 */
/*
int dist2(pos_t src, pos_t dest){
    int x_dist = abs(dest.r - src.r);
    int y_dist = abs(dest.c - src.c);
    return x_dist + y_dist;
}
*/

/*
 * Move civilian from src to dest in the map (when calling the function cell(src) must be SURVIVOR)
 */ 
void move_civ(pos_t src, pos_t dest){
    grid[src.r][src.c] = NONE;
    grid[dest.r][dest.c] = SURVIVOR;
}

/*
 * Move first responder from src to dest in the map (when calling the function cell(src) must be FIRST_R)
 */ 
void move_fr(pos_t src, pos_t dest){
    grid[src.r][src.c] = NONE;
    grid[dest.r][dest.c] = FIRST_R;
}

/*
 * Retrieve index of a civilian from its position
 */
int get_civ_idx(pos_t pos){
    int i;
    for(i = 0; i &lt; N_CIVILIANS; i++){
        if(pos_civilians[i] == pos) return i;
    }
    return -1;
}

/*
 * Get the next cell to go to reach the objective
 */
void getNextCellToGoTo(pos_t &amp;pos1, pos_t &amp;pos2, pos_t &amp;ret_pos){
    int x_move, y_move;
    if(pos1.r &gt; pos2.r){
        y_move = -1;
    } else if(pos1.r = pos2.r){
        y_move = 0; // No vertical movement
    } else{
        y_move = 1;
    }
    
    if(pos1.c &gt; pos2.c){
        x_move = -1;
    } else if(pos1.c = pos2.c){
        x_move = 0; // No horizontal movement
    } else{
        x_move = 1;
    }

    ret_pos.r = pos1.r + y_move;
    ret_pos.c = pos1.c + x_move;
}

/*
 * Check if cell is free
 */
bool isCellFree(pos_t p) {
    if (cell(p) == NONE){
        return true;
    }else{
        return false;
    }
}</declaration>
	<template>
		<name>First_Responder</name>
		<parameter>fr_t p_id</parameter>
		<declaration>/*
const int FREE = 0;
const int NEAR_DANGER = 1;
const int CALLED = 2;
const int FINISHED = 3;
*/
const int FINISHED = -1;
const int FREE = 8;
const int CALLED = 9;
const int NEAR_DANGER = 10;

clock x;
int id, k;                           // Id and trajectory index
pos_t pos;                           // Position in the map
pos_t trajectory[MAX_TRAJ];          // Trajectory
int traj_l;                          // Trajectory length
int status = FREE;                   // Status
int time_to_assist = -1;             // Time to rescue a civilian       
int civ_id;                          // Id of the civilian rescue


/*
 * Check if near a Civilian in danger
 */
bool nearCivilianInDanger() {
    int i, j;
    pos_t civ_pos;
    for (j=-1; j&lt;=1; j++) {
        for (i=-1; i&lt;=1; i++) {
            if (pos.r+i &gt;= 0 &amp;&amp; pos.c+j &gt;= 0 &amp;&amp; pos.r+i &lt; GRID_HEIGHT &amp;&amp; pos.c+j &lt; GRID_LENGTH &amp;&amp; cell_int(pos.r+i, pos.c+j) == NEED_ASSIST){
                civ_pos.r = pos.r+i;
                civ_pos.c = pos.c+j;
                civ_id = get_civ_idx(civ_pos);
                return true;
            }
        }
    }
    return false;
}

/*
 * Enter the map at the entry point.
 */
void enter() {
    id = p_id;
    pos = pos_FRs[id];
    if (nearCivilianInDanger()) {
        status = NEAR_DANGER;
    }
}

/*
 * Calculate total time to assist a civilian in danger
 */
void timeToAssist() {
    if (status == NEAR_DANGER) {
        time_to_assist = T_FR;
    } else {
        time_to_assist = T_FR + dist(pos, pos_civilians[civ_id]) + dist(pos_civilians[caller_id], pos);
    }
}


/*
 * Update global position Array
 */
void update_FR_pos() {
    pos_FRs[id] = pos;
}

/*
 * Get closer fire
 */
int getCloserFire(pos_t pos){
    int i, min = MAX_INT;
    int closer_fire = -1;
    for(i=0; i &lt; N_EXITS; i++){
        if(dist(fires[i], pos) &lt; min){
            min = dist(fires[i], pos);
            closer_fire = i;
        }
    }
    return closer_fire;
}

// TODO: da sistemare, aggiornare posizione se gi√† vicino ad un fuoco
/*
 * Step in fire direction, greater probability to find a civilian to help
 */
void step_fire(){
    // Check if need to move
    if ((saved+casualties) == N_CIVILIANS) {
        status = FINISHED;
    } else {
        pos_t closest_fire = fires[getCloserFire(pos)], next = OUT_OF_MAP;
        if (pos != closest_fire) {
            getNextCellToGoTo(pos, closest_fire, next);
        } else {
            next = pos;
        }
        if(isCellFree(next)){
            grid[pos.r][pos.c] = NONE;
            pos = next;
            grid[pos.r][pos.c] = FIRST_R;
        }
        update_FR_pos();
    }
}


void movementPolicy(){
    int tries = 0;
    bool valid_step_found = false;
     
    int step_dir = 0;
    if(fr_movement_policy == RANDOM){
        
      while (valid_step_found == false &amp;&amp; tries &lt; 8) {
        if (step_dir == 0 &amp;&amp; pos.r+1 &lt; GRID_HEIGHT &amp;&amp; cell_int(pos.r+1, pos.c) == NONE) { // Move down
            grid[pos.r][pos.c] = NONE;
            pos.r++;
            grid[pos.r][pos.c] = FIRST_R;
            valid_step_found = true;
        }
        if (step_dir == 1 &amp;&amp; pos.r-1 &gt;= 0 &amp;&amp; cell_int(pos.r-1, pos.c) == NONE) { // Move up
            grid[pos.r][pos.c] = NONE;
            pos.r--;
            grid[pos.r][pos.c] = FIRST_R;
            valid_step_found = true;
        }
        if (step_dir == 2 &amp;&amp; pos.c-1 &gt;= 0 &amp;&amp; cell_int(pos.r, pos.c-1) == NONE) { // Move left
            grid[pos.r][pos.c] = NONE;
            pos.c--;
            grid[pos.r][pos.c] = FIRST_R;
            valid_step_found = true;
        }
        if (step_dir == 3 &amp;&amp; pos.c+1 &lt; GRID_LENGTH &amp;&amp; cell_int(pos.r, pos.c+1) == NONE) { // Move right
            grid[pos.r][pos.c] = NONE;
            pos.c++;
            grid[pos.r][pos.c] = FIRST_R;
            valid_step_found = true;
        }
        if (step_dir == 4 &amp;&amp; pos.r+1 &lt; GRID_HEIGHT &amp;&amp; pos.c-1 &gt;= 0 &amp;&amp; cell_int(pos.r+1, pos.c-1) == NONE) { // Move down-left
            grid[pos.r][pos.c] = NONE;
            pos.r++;
            pos.c--;
            grid[pos.r][pos.c] = FIRST_R;
            valid_step_found = true;
        }
        if (step_dir == 5 &amp;&amp; pos.r+1 &lt; GRID_HEIGHT &amp;&amp; pos.c+1 &lt; GRID_LENGTH &amp;&amp; cell_int(pos.r+1, pos.c+1) == NONE) { // Move down-right
            grid[pos.r][pos.c] = NONE;
            pos.r++;
            pos.c++;
            grid[pos.r][pos.c] = FIRST_R;
            valid_step_found = true;
        }
        if (step_dir == 6 &amp;&amp; pos.r-1 &gt;= 0 &amp;&amp; pos.c-1 &gt;= 0 &amp;&amp; cell_int(pos.r-1, pos.c-1) == NONE) { // Move up-left
            grid[pos.r][pos.c] = NONE;
            pos.r--;
            pos.c--;
            grid[pos.r][pos.c] = FIRST_R;
            valid_step_found = true;
        }
        if (step_dir == 7 &amp;&amp; pos.r-1 &gt;= 0 &amp;&amp; pos.c+1 &lt; GRID_LENGTH &amp;&amp; cell_int(pos.r-1, pos.c+1) == NONE) { // Move up-right
            grid[pos.r][pos.c] = NONE;
            pos.r--;
            pos.c++;
            grid[pos.r][pos.c] = FIRST_R;
            valid_step_found = true;
        }
        step_dir = (step_dir+1) % 8;
        if (valid_step_found == false) {
            tries++;
        }
        }
    }

}

// TODO: change to put moveFr??
void step() {

    // Check if need to move
    if ((saved+casualties) == N_CIVILIANS) {
        status = FINISHED;
    } else {
        // Random policy
        movementPolicy();

        update_FR_pos();

        if (nearCivilianInDanger()) {
            status = NEAR_DANGER;
        }
    }
}


// TODO capire come gestire la precenza tra near danger e la ricezione della richiesta di aiuto: dovrebbe essere l'ordine di dichiarazione dei chan
/*
 * Update global grid by setting FR busy or not
 */
void updateGrid() {
    if (grid[pos.r][pos.c] == FIRST_R &amp;&amp; status == NEAR_DANGER) {
        grid[pos.r][pos.c] = FIRST_R_BUSY_NEAR_DANGER;
    } else if (grid[pos.r][pos.c] == FIRST_R &amp;&amp; status == CALLED) {
        grid[pos.r][pos.c] = FIRST_R_BUSY_CALLED;
    } else if (grid[pos.r][pos.c] == FIRST_R_BUSY_NEAR_DANGER || grid[pos.r][pos.c] == FIRST_R_BUSY_CALLED) {
        grid[pos.r][pos.c] = FIRST_R;
    }
}

// TODO: Change it in order to properly set the pos_to_save
/*

 * Step function that follows a specified trajectory. Updates grid and global FR position array and checks new status
 */
/*
void step() {
    k = (k+1) % traj_l;
    if(isCellFree(trajectory[k])){
        grid[pos.r][pos.c] = NONE;
        pos = trajectory[k];
        grid[pos.r][pos.c] = FIRST_R;   
    } else {
        k = k - 1;
    }
    update_FR_pos();
    if (nearCivilianInDanger()) {
        status = NEAR_DANGER;
    }
}
*/

/*
 * Update when a help request is received
 */
void helpReqReceived() {
    status = CALLED;
    updateGrid();
    civ_id = get_civ_idx(pos_to_save);
    pos_to_save = OUT_OF_MAP;
}

/*
 * Update when starting to help someone near
 */
void nearDanger() {
    x = 0;
    updateGrid();
    timeToAssist();
    pos_to_save = OUT_OF_MAP;
}

/*
 * Update when returning to Moving state
 */
void retToMove() {
    status = FREE;
    x = 0;
    updateGrid();
    time_to_assist = -1;
}</declaration>
		<location id="id0" x="-628" y="-93">
		</location>
		<location id="id1" x="-366" y="68">
			<name x="-433" y="42">Moving</name>
			<label kind="invariant" x="-484" y="76">x&lt;=STEP_TIME</label>
		</location>
		<location id="id2" x="118" y="68">
			<name x="136" y="42">Helping</name>
			<label kind="invariant" x="127" y="76">x&lt;=time_to_assist</label>
		</location>
		<location id="id3" x="-119" y="68">
			<name x="-161" y="34">FR_Received</name>
			<committed/>
		</location>
		<location id="id4" x="-365" y="-93">
			<committed/>
		</location>
		<location id="id5" x="-365" y="-255">
			<name x="-375" y="-289">Finished</name>
		</location>
		<init ref="id0"/>
		<transition id="id6">
			<source ref="id4"/>
			<target ref="id5"/>
			<label kind="guard" x="-357" y="-187">status == FINISHED</label>
		</transition>
		<transition id="id7">
			<source ref="id4"/>
			<target ref="id1"/>
			<label kind="guard" x="-323" y="-25">status == FREE</label>
			<nail x="-331" y="-17"/>
		</transition>
		<transition id="id8">
			<source ref="id2"/>
			<target ref="id1"/>
			<label kind="synchronisation" x="-196" y="263">civ_dead[civ_id]?</label>
			<label kind="assignment" x="-170" y="289">retToMove()</label>
			<nail x="118" y="288"/>
			<nail x="-366" y="288"/>
		</transition>
		<transition id="id9">
			<source ref="id3"/>
			<target ref="id2"/>
			<label kind="synchronisation" x="-60" y="51">helping[civ_id]!</label>
			<label kind="assignment" x="-60" y="68">x=0, 
timeToAssist()</label>
		</transition>
		<transition id="id10">
			<source ref="id1"/>
			<target ref="id3"/>
			<label kind="synchronisation" x="-298" y="51">FR_help_req[id]?</label>
			<label kind="assignment" x="-306" y="68">helpReqReceived()</label>
		</transition>
		<transition id="id11">
			<source ref="id4"/>
			<target ref="id2"/>
			<label kind="guard" x="-102" y="-85">status == NEAR_DANGER</label>
			<label kind="synchronisation" x="-77" y="-68">helping[civ_id]!</label>
			<label kind="assignment" x="-60" y="-51">nearDanger()</label>
			<nail x="119" y="-93"/>
		</transition>
		<transition id="id12">
			<source ref="id1"/>
			<target ref="id4"/>
			<label kind="guard" x="-543" y="-25">x == STEP_TIME</label>
			<label kind="assignment" x="-535" y="-8">step(), x=0</label>
			<nail x="-399" y="-17"/>
		</transition>
		<transition id="id13">
			<source ref="id2"/>
			<target ref="id1"/>
			<label kind="guard" x="-196" y="144">x == time_to_assist</label>
			<label kind="synchronisation" x="-196" y="161">saved_by_FR[civ_id]!</label>
			<label kind="assignment" x="-162" y="186">retToMove()</label>
			<nail x="118" y="186"/>
			<nail x="-366" y="186"/>
		</transition>
		<transition id="id14">
			<source ref="id0"/>
			<target ref="id4"/>
			<label kind="synchronisation" x="-552" y="-136">init_done?</label>
			<label kind="assignment" x="-535" y="-119">enter()</label>
		</transition>
	</template>
	<template>
		<name>Civilian</name>
		<parameter>civ_t p_id</parameter>
		<declaration>/*
const int SAVED = 1;
const int DANGER = 2;
const int STEP = 3;
const int ZERO_RESP = 4;
const int CIV_ASSISTED = 5;
const int DEAD = 6;
const int BUSY = 7;
*/
const int SAVED = -1;
const int DEAD = -1;
const int STEP = 3;
const int ZERO_RESP = 4;
const int DANGER = 5;
const int CIV_ASSISTED = 6;
const int BUSY = 7;

clock x;
int id;                    // Id
pos_t pos;                 // Position
int status = 0;            // Status
int timeToAssist = -1;     // Time to rescue another civilian
int civ_need_id;           // Id of the civilian to help (ZR case)
int fr_id;                 // Id of the FR to call
int delta_r, delta_c;

/*
 * Golden rule to check:
 * for every transition check clock update (if necessary), internal status update, grid update
 */

// TODO: clean pos_to_save
// TODO: occhio alla direzione verso le uscite
// TODO: togliere ridondanza sulla posizione
/*
 * Get closer exit
 */
int getCloserExit(pos_t pos){
    int i, min = MAX_INT;
    int closer_exit = -1;
    for(i=0; i &lt; N_EXITS; i++){
        if(dist(exits[i], pos) &lt; min){
            min = dist(exits[i], pos);
            closer_exit = i;
        }
    }

    return closer_exit;
}

/*
 * Check civilian status
 */
int computeStatus(int px, int py){
     // check Exit
    int i, j;
    for(i = -1; i &lt; 2; i++){
        for(j = -1; j &lt; 2; j++){
            if(cell_int(px + i, py + j) == EXIT) return SAVED;
        }
    }
    // check Fire 
    for(i = -1; i &lt; 2; i++){
        for(j = -1; j &lt; 2; j++){
            if(cell_int(px + i, py + j) == FIRE) return DANGER;
        }
    }
    return STEP;
}

void movementPolicy(){
    pos_t next_cell;
    pos_t ret_pos = OUT_OF_MAP;
    pos_t exit_cell = exits[getCloserExit(pos)];

    if (civ_moving_policy == CLOSER_EXIT){

        getNextCellToGoTo(pos, exit_cell, ret_pos);
        next_cell = ret_pos;
    
        // Check if next_cell is free
        if (isCellFree(next_cell)) {
            move_civ(pos, next_cell);
            pos = next_cell;
        }
    }

}

void step() {

    movementPolicy();

    status = computeStatus(pos.r, pos.c);
    
    if (status == DANGER) grid[pos.r][pos.c] = NEED_ASSIST;

    pos_civilians[id] = pos;
}

/*
 * Compute Zero Responder time needed to assist a civilian in danger
 */
void computeTimeToAssist() {
    // Calculate the time needed to reach the person in danger.
    timeToAssist = dist(pos, pos_to_save) + T_ZR;
}

/*
 * Civilian dies
 */
void casualtyOccurred() {
    grid[pos.r][pos.c] = NONE;
    pos.r = -1;
    pos.c = -1;
    pos_civilians[id] = pos;
    status = DEAD;
    casualties++;
}

/*
 * Civilian is safe
 */
void safeOccurred() {
    grid[pos.r][pos.c] = NONE;
    pos.r = -1;
    pos.c = -1;
    pos_civilians[id] = pos;
    status = SAVED;
    saved++;
}
/*
 * Enter the map at the entry point.
 */
void enter() {
    id = p_id;
    pos.r = pos_civilians[id].r;
    pos.c = pos_civilians[id].c;
    status = computeStatus(pos.r, pos.c);
    if (status == DANGER) grid[pos.r][pos.c] = NEED_ASSIST;
}

/*
 * Get civilian in danger id
 */
void getCivInNeed(){
    civ_need_id = get_civ_idx(pos_to_save);
}

/*
 * Civilian start helping (ZR case)
 */
void zrOccurred(){
    x = 0;
    computeTimeToAssist();
    status = ZERO_RESP;
    grid[pos.r][pos.c] = ZERO_R;
    pos_to_save = OUT_OF_MAP;
}

/*
 * Get closer first responder
 */
int getCloserFR(pos_t pos){
    pos_t fr_pos;
    int i, fr_id = -1, min_dist = MAX_INT;
    for(i = 0; i &lt; N_FIRST_RESPONDERS; i++){
        if(dist(pos, pos_FRs[i]) &lt; min_dist &amp;&amp; grid[pos_FRs[i].r][pos_FRs[i].c] == FIRST_R){
            fr_id = i;
            min_dist = dist(pos, pos_FRs[i]);
        }
    }
    return fr_id;
}

/*
 * Civilian instructed to call FR
 */
void frOccurred(){
    fr_id = getCloserFR(pos);
    civ_need_id = get_civ_idx(pos_to_save);
    status = BUSY;
    grid[pos.r][pos.c] = CONTACTING;
    caller_id = id;
}

/*
 * Civilian gets help
 */
void helpingOccurred(){
    status = CIV_ASSISTED;
    grid[pos.r][pos.c] = ASSISTED;
}

/*
 * Civilian dies before it's saved
 */
void extCasualtyOccurred(){
    x=0;
    status = STEP;
    grid[pos.r][pos.c] = SURVIVOR;
}</declaration>
		<location id="id15" x="-671" y="-68">
		</location>
		<location id="id16" x="-144" y="-68">
			<name x="-127" y="-85">Danger</name>
			<label kind="invariant" x="-127" y="-68">x&lt;=T_V</label>
		</location>
		<location id="id17" x="-144" y="187">
			<name x="-195" y="187">Safe</name>
		</location>
		<location id="id18" x="-144" y="-323">
			<name x="-204" y="-365">Moving</name>
			<label kind="invariant" x="-255" y="-348">x&lt;=STEP_TIME</label>
		</location>
		<location id="id19" x="382" y="-323">
			<name x="407" y="-348">Helping</name>
			<label kind="invariant" x="407" y="-323">x&lt;=timeToAssist</label>
		</location>
		<location id="id20" x="-442" y="-68">
			<committed/>
		</location>
		<location id="id21" x="-348" y="59">
			<name x="-399" y="59">Dead</name>
		</location>
		<location id="id22" x="612" y="-484">
			<name x="629" y="-501">Contacting</name>
		</location>
		<location id="id23" x="-144" y="59">
			<name x="-127" y="42">Helped</name>
			<label kind="invariant" x="-127" y="59">x&lt;=T_V</label>
		</location>
		<location id="id24" x="85" y="-323">
			<name x="51" y="-365">ZR_Received</name>
			<committed/>
		</location>
		<location id="id25" x="204" y="-484">
			<committed/>
		</location>
		<location id="id26" x="-144" y="-187">
			<committed/>
		</location>
		<branchpoint id="id27" x="127" y="-323"/>
		<branchpoint id="id28" x="272" y="-484"/>
		<init ref="id15"/>
		<transition id="id29">
			<source ref="id27"/>
			<target ref="id19"/>
			<label kind="synchronisation" x="170" y="-323">helping[civ_need_id]!</label>
			<label kind="assignment" x="204" y="-306">zrOccurred()</label>
			<label kind="probability" x="161" y="-348">P_listen</label>
		</transition>
		<transition id="id30">
			<source ref="id27"/>
			<target ref="id18"/>
			<label kind="probability" x="51" y="-280">P_ignore</label>
			<nail x="127" y="-280"/>
			<nail x="-51" y="-280"/>
		</transition>
		<transition id="id31" controllable="false">
			<source ref="id24"/>
			<target ref="id27"/>
		</transition>
		<transition id="id32">
			<source ref="id28"/>
			<target ref="id18"/>
			<label kind="probability" x="280" y="-544">P_ignore</label>
			<nail x="272" y="-535"/>
			<nail x="-68" y="-535"/>
		</transition>
		<transition id="id33">
			<source ref="id28"/>
			<target ref="id22"/>
			<label kind="synchronisation" x="373" y="-510">FR_help_req[fr_id]!</label>
			<label kind="probability" x="323" y="-476">P_listen</label>
		</transition>
		<transition id="id34" controllable="false">
			<source ref="id25"/>
			<target ref="id28"/>
		</transition>
		<transition id="id35">
			<source ref="id26"/>
			<target ref="id18"/>
			<label kind="guard" x="-110" y="-263">status == STEP</label>
			<nail x="-119" y="-255"/>
		</transition>
		<transition id="id36">
			<source ref="id23"/>
			<target ref="id17"/>
			<label kind="synchronisation" x="-314" y="136">saved_by_FR[id]?</label>
			<label kind="assignment" x="-297" y="153">safeOccurred()</label>
			<nail x="-170" y="127"/>
		</transition>
		<transition id="id37">
			<source ref="id18"/>
			<target ref="id24"/>
			<label kind="synchronisation" x="-102" y="-340">call_zero_resp[id]?</label>
			<label kind="assignment" x="-85" y="-323">getCivInNeed()</label>
		</transition>
		<transition id="id38">
			<source ref="id23"/>
			<target ref="id21"/>
			<label kind="guard" x="-280" y="59">x==T_V</label>
			<label kind="synchronisation" x="-306" y="76">civ_dead[id]!</label>
			<label kind="assignment" x="-331" y="93">casualtyOccurred()</label>
		</transition>
		<transition id="id39">
			<source ref="id16"/>
			<target ref="id23"/>
			<label kind="synchronisation" x="-102" y="-25">helping[id]?</label>
			<label kind="assignment" x="-127" y="-8">helpingOccurred()</label>
		</transition>
		<transition id="id40">
			<source ref="id22"/>
			<target ref="id18"/>
			<label kind="synchronisation" x="119" y="-603">civ_dead[civ_need_id]?</label>
			<label kind="assignment" x="119" y="-578">extCasualtyOccurred()</label>
			<nail x="612" y="-577"/>
			<nail x="-144" y="-578"/>
		</transition>
		<transition id="id41">
			<source ref="id22"/>
			<target ref="id17"/>
			<label kind="synchronisation" x="620" y="9">saved_by_FR[civ_need_id]?</label>
			<label kind="assignment" x="620" y="34">safeOccurred()</label>
			<nail x="612" y="187"/>
		</transition>
		<transition id="id42">
			<source ref="id18"/>
			<target ref="id25"/>
			<label kind="synchronisation" x="8" y="-510">call_first_resp[id]?</label>
			<label kind="assignment" x="42" y="-484">frOccurred()</label>
			<nail x="-25" y="-484"/>
		</transition>
		<transition id="id43">
			<source ref="id19"/>
			<target ref="id18"/>
			<label kind="synchronisation" x="119" y="-433">civ_dead[civ_need_id]?</label>
			<label kind="assignment" x="119" y="-407">extCasualtyOccurred()</label>
			<nail x="382" y="-407"/>
			<nail x="76" y="-408"/>
		</transition>
		<transition id="id44">
			<source ref="id16"/>
			<target ref="id21"/>
			<label kind="guard" x="-357" y="-42">x==T_V</label>
			<label kind="synchronisation" x="-382" y="-25">civ_dead[id]!</label>
			<label kind="assignment" x="-416" y="-8">casualtyOccurred()</label>
		</transition>
		<transition id="id45">
			<source ref="id19"/>
			<target ref="id17"/>
			<label kind="guard" x="391" y="-17">x==timeToAssist</label>
			<label kind="synchronisation" x="391" y="9">saved_by_ZR[civ_need_id]!</label>
			<label kind="assignment" x="391" y="34">safeOccurred()</label>
			<nail x="383" y="187"/>
		</transition>
		<transition id="id46">
			<source ref="id20"/>
			<target ref="id17"/>
			<label kind="guard" x="-578" y="51">status == SAVED</label>
			<label kind="assignment" x="-569" y="76">safeOccurred()</label>
			<nail x="-442" y="187"/>
		</transition>
		<transition id="id47">
			<source ref="id20"/>
			<target ref="id16"/>
			<label kind="guard" x="-357" y="-93">status == DANGER</label>
		</transition>
		<transition id="id48">
			<source ref="id20"/>
			<target ref="id18"/>
			<label kind="guard" x="-570" y="-306">status == STEP</label>
			<nail x="-442" y="-323"/>
		</transition>
		<transition id="id49">
			<source ref="id15"/>
			<target ref="id20"/>
			<label kind="synchronisation" x="-646" y="-93">init_done?</label>
			<label kind="assignment" x="-646" y="-68">enter()</label>
		</transition>
		<transition id="id50">
			<source ref="id26"/>
			<target ref="id16"/>
			<label kind="guard" x="-136" y="-153">status == DANGER</label>
			<label kind="assignment" x="-85" y="-136">x=0</label>
		</transition>
		<transition id="id51">
			<source ref="id18"/>
			<target ref="id26"/>
			<label kind="guard" x="-306" y="-263">x==STEP_TIME</label>
			<label kind="assignment" x="-340" y="-246">step(), x=0</label>
			<nail x="-170" y="-255"/>
		</transition>
		<transition id="id52">
			<source ref="id26"/>
			<target ref="id17"/>
			<label kind="guard" x="93" y="-17">status == SAVED</label>
			<label kind="assignment" x="93" y="9">safeOccurred()</label>
			<nail x="85" y="-187"/>
			<nail x="85" y="187"/>
		</transition>
		<transition id="id53">
			<source ref="id23"/>
			<target ref="id17"/>
			<label kind="synchronisation" x="-110" y="136">saved_by_ZR[id]?</label>
			<label kind="assignment" x="-102" y="153">safeOccurred()</label>
			<nail x="-119" y="127"/>
		</transition>
	</template>
	<template>
		<name>Initializer</name>
		<declaration>/*
 * Build exits global array
 */
void build_exits() {
    int i, j, idx = 0;
    for(i=0; i &lt; GRID_LENGTH; i++){
        for(j=0; j &lt; GRID_HEIGHT; j++){
            if(cell_int(i, j) == EXIT){
                exits[idx].r = i;
                exits[idx].c = j;
                idx++;
            }
        }
    }
}

/*
 * Build fires global array
 */
void build_fires() {
    int i, j, idx = 0;
    for(i=0; i &lt; GRID_LENGTH; i++){
        for(j=0; j &lt; GRID_HEIGHT; j++){
            if(cell_int(i, j) == FIRE){
                fires[idx].r = i;
                fires[idx].c = j;
                idx++;
            }
        }
    }
}

/*
 * Build FRs global array
 */
void set_FR_pos() {
    int i, j, idx = 0;
    for(i=0; i &lt; GRID_LENGTH; i++){
        for(j=0; j &lt; GRID_HEIGHT; j++){
            if(cell_int(i, j) == FIRST_R){
                pos_FRs[idx].r = i;
                pos_FRs[idx].c = j;
                idx++;
            }
        }
    }
}

/*
 * Compute trajectory lenghts
 */
void compute_traj_lengths(){
    int i, j;
    pos_t init_pos, curr_pos;
    for(i = 0; i &lt; N_DRONES; i++){
        init_pos = drone_trajectories[i][0];
        curr_pos = drone_trajectories[i][1];
        for(j = 1; j &lt; MAX_TRAJ; j++){
            if(curr_pos == init_pos){
                drone_traj_lengths[i] = j;
                j = MAX_TRAJ; // break
            } else {
                curr_pos = drone_trajectories[i][j];  
            }
        }
    }
}

/*
 * Build civilians global array
 */
void set_civ_pos(){
    int i, j, idx = 0;
    for(i=0; i &lt; GRID_LENGTH; i++){
        for(j=0; j &lt; GRID_HEIGHT; j++){
            if(cell_int(i, j) == SURVIVOR || cell_int(i, j) == NEED_ASSIST){
                pos_civilians[idx].r = i;
                pos_civilians[idx].c = j;
                idx++;
            }
        }
    }
}

void init_all() {
    build_exits();
    set_FR_pos();
    set_civ_pos();
    compute_traj_lengths();
}</declaration>
		<location id="id54" x="-357" y="-76">
			<committed/>
		</location>
		<location id="id55" x="-221" y="-76">
		</location>
		<init ref="id54"/>
		<transition id="id56">
			<source ref="id54"/>
			<target ref="id55"/>
			<label kind="synchronisation" x="-339" y="-93">init_done!</label>
			<label kind="assignment" x="-339" y="-76">init_all()</label>
		</transition>
	</template>
	<template>
		<name x="9" y="9">Drone</name>
		<parameter>dr_t p_id</parameter>
		<declaration>/*
const int STEP = 1;
const int DRONE_ZERO_R = 2;
const int DRONE_FIRST_R = 3;
const int FINISHED = 4;
*/
const int FINISHED = -1;
const int STEP = 11;
const int DRONE_ZERO_R = 12;
const int DRONE_FIRST_R = 13;

clock x;
int id;                                // Id
pos_t trajectory[MAX_TRAJ];            // Trajectory            
int traj_l;                            // Trajectory Length            
int k;                                 // Trajectory index               
int status = STEP;                     // Status
pos_t pos;                             // Position
int zr;                                // ZeroResponder 
bool returning = false;

// TODO: check the right status even when entering in the map
// TODO: bug when signaling zr and two in need in range

/*
 * Enter the map at the entry point.
 */
void enter() {
    id = p_id;
    trajectory = drone_trajectories[id];
    pos = trajectory[k];
    k = 0;
    traj_l = drone_traj_lengths[id];
}

/*
 * Check if a civilian in danger is in drone sight and return its position
 */
pos_t civilianInDangerInRange(){
    int i, j;
    pos_t ret_pos = {-1, -1};
    for(i = -N_V; i &lt;= N_V; i++){
        for(j = -N_V; j &lt;= N_V; j++){
            pos_t pos = trajectory[k];
            if (cell_int(pos.r + i, pos.c + j) == NEED_ASSIST){
                pos_t ret_pos = {pos.r + i, pos.c + j};
                return ret_pos;
            }
        }
    }
    return ret_pos;
}

/*
 * Check if a zero responder is in drone sight and return its position
 */
pos_t zeroResponderInRange(){
    int i, j;
    pos_t ret_pos = {-1, -1};
    for(i = -N_V; i &lt;= N_V; i++){
        for(j = -N_V; j &lt;= N_V; j++){
            pos_t pos = trajectory[k];
            if (cell_int(pos.r + i, pos.c + j) == SURVIVOR){
                pos_t ret_pos = {pos.r + i, pos.c + j};
                return ret_pos;
            }
        }
    }
    return ret_pos;
}

/*
 * Get closer first responder
 */
pos_t getCloserFR(pos_t pos){
    pos_t fr_pos;
    int i, fr_id = -1, min_dist = MAX_INT;
    for(i = 0; i &lt; N_FIRST_RESPONDERS; i++){
        if(dist(pos, pos_FRs[i]) &lt; min_dist &amp;&amp; grid[pos_FRs[i].r][pos_FRs[i].c] == FIRST_R){
            fr_id = i;
            min_dist = dist(pos, pos_FRs[i]);
        }
    }
    return pos_FRs[fr_id];
}

/*
 * Decide to ask for direct help or to call first responder (Random decision)
 */
void decisionPolicy(pos_t civInDanger, pos_t potentialZr) {
    int dec, i, count = 0;
    pos_t closerFr;
    // Case in which there are no free first responders
    for(i = 0; i &lt; N_FIRST_RESPONDERS; i++){
        if(cell(pos_FRs[i]) == FIRST_R){
            count++;
        }
    }
    if(count == 0){
        dec = 0;
        return;
    }

    // Compute the action based on the given policy    
    if(drone_decision_policy == ALWAYS_ZR){
        dec = 0;
    }
    else if(drone_decision_policy == ALWAYS_FR){
        dec = 1; // from the previous check at least one fr is free
    }
    else if(drone_decision_policy == MIN_TIME){
        closerFr = getCloserFR(civInDanger);
        if((dist(closerFr, civInDanger) + dist(potentialZr, closerFr) + T_FR) &lt;= (dist(potentialZr, civInDanger) + T_ZR)){
            dec = 1;
        }else{
            dec = 0;
        }
    }
    
    // Update status according to the result given by the action following globally-defined policy
    if(dec == 0){
        status = DRONE_ZERO_R;
    } 
    else{
        status = DRONE_FIRST_R;
    }
}


// TODO: Change it in order to properly set the pos_to_save
/*
 * Step function that follows a specified trajectory (for random decision)
 */
void step() {
    int i;
    pos_t civ_in_danger, potential_zr;

    // Check if need to move
    if (saved+casualties == N_CIVILIANS) {
        status = FINISHED;
    } else {
        // Do one step along the trajectory and then go back
        if (k == traj_l - 1) {
            returning = true;
        } 
        if (!returning) {
            k++;
        } else {
            k--;
        }

        if (k == 0) {
            returning = false;
        }
        
        pos = trajectory[k];

        // Explore visibility range
        civ_in_danger = civilianInDangerInRange();
        potential_zr = zeroResponderInRange();

        // Find id of the civilian to call (either as a zr either to call a fr)
        zr = get_civ_idx(potential_zr);
        if (civ_in_danger != OUT_OF_MAP &amp;&amp; potential_zr != OUT_OF_MAP) {
            pos_to_save = civ_in_danger;
            decisionPolicy(civ_in_danger, potential_zr);
        }
    }
}

// TODO: Change it in order to properly set the pos_to_save
/*
 * Step function that follows a specified trajectory (for min time decision)
 */
/*
void step() {
    int i;
    pos_t civ_in_danger, potential_zr;

    // Check if need to move
    if (saved+casualties == N_CIVILIANS) {
        status = FINISHED;
    } else {
        // Do one step along the trajectory
        k = (k+1) % traj_l;
        pos = trajectory[k];

        // Explore visibility range
        civ_in_danger = civilianInDangerInRange();
        potential_zr = zeroResponderInRange();

        // Find id of the civilian to call (either as a zr either to call a fr)
        zr = get_civ_idx(potential_zr);
        if (civ_in_danger != OUT_OF_MAP &amp;&amp; potential_zr != OUT_OF_MAP) {
            pos_to_save = civ_in_danger;
            decisionPolicy(civ_in_danger, potential_zr);
        }
    }
}
*/


/*
 * Decide to ask for direct help or to call first responder (min time decision)
 */
/*
void decisionPolicy(pos_t civInDanger, pos_t potentialZr) {
    int dec, i, count = 0;
    pos_t closerFr;
    for(i = 0; i &lt; N_FIRST_RESPONDERS; i++){
        if(cell(pos_FRs[i]) == FIRST_R){
            count++;
        }
    }
    if(count == 0){
        dec = 0;
    }else{
        closerFr = getCloserFR(civInDanger);
        if((dist(closerFr, civInDanger) + dist(potentialZr, closerFr) + T_FR) &lt;= (dist(potentialZr, civInDanger) + T_ZR)){
            dec = 1;
        }else{
            dec = 0;
        }
    }

    if(dec == 0){
        status = DRONE_ZERO_R;
    } 
    else{
        status = DRONE_FIRST_R;
    }
}
*/

/*
 * Decide to ask for direct help or to call first responder (if a first responder is free always call one)
 */
/*
void decisionPolicy() {
    int dec, i, count = 0;
    for(i = 0; i &lt; N_FIRST_RESPONDERS; i++){
        if(cell(pos_FRs[i]) == FIRST_R){
            count++;
        }
    }
    if(count == 0){
        dec = 0;
    }else{
        dec = 1;
    }
    if(dec == 0){
        status = DRONE_ZERO_R;
    } 
    else{
        status = DRONE_FIRST_R;
    }
}
*/</declaration>
		<location id="id57" x="-1045" y="-76">
		</location>
		<location id="id58" x="-765" y="-76">
			<name x="-833" y="-102">Moving</name>
			<label kind="invariant" x="-884" y="-68">x&lt;=STEP_TIME</label>
		</location>
		<location id="id59" x="-544" y="-76">
			<committed/>
		</location>
		<location id="id60" x="-297" y="-76">
			<name x="-307" y="-110">Finish</name>
		</location>
		<branchpoint id="id61" x="-688" y="102"/>
		<branchpoint id="id62" x="-680" y="-255"/>
		<init ref="id57"/>
		<transition id="id63">
			<source ref="id61"/>
			<target ref="id58"/>
			<label kind="probability" x="-697" y="42">P_fail</label>
		</transition>
		<transition id="id64">
			<source ref="id61"/>
			<target ref="id58"/>
			<label kind="synchronisation" x="-943" y="34">call_first_resp[zr]!</label>
			<label kind="probability" x="-748" y="110">P_succ</label>
			<nail x="-765" y="102"/>
		</transition>
		<transition id="id65">
			<source ref="id62"/>
			<target ref="id58"/>
			<label kind="synchronisation" x="-935" y="-238">call_zero_resp[zr]!</label>
			<label kind="probability" x="-748" y="-280">P_succ</label>
			<nail x="-765" y="-255"/>
		</transition>
		<transition id="id66">
			<source ref="id62"/>
			<target ref="id58"/>
			<label kind="probability" x="-697" y="-204">P_fail</label>
		</transition>
		<transition id="id67" controllable="false">
			<source ref="id59"/>
			<target ref="id61"/>
			<label kind="guard" x="-535" y="25">status == DRONE_FIRST_R</label>
			<label kind="assignment" x="-501" y="42">status = STEP</label>
			<nail x="-544" y="102"/>
		</transition>
		<transition id="id68" controllable="false">
			<source ref="id59"/>
			<target ref="id62"/>
			<label kind="guard" x="-535" y="-221">status == DRONE_ZERO_R</label>
			<label kind="assignment" x="-501" y="-204">status = STEP</label>
			<nail x="-544" y="-255"/>
		</transition>
		<transition id="id69">
			<source ref="id59"/>
			<target ref="id60"/>
			<label kind="guard" x="-501" y="-102">status == FINISHED</label>
		</transition>
		<transition id="id70">
			<source ref="id59"/>
			<target ref="id58"/>
			<label kind="guard" x="-714" y="-42">status == STEP</label>
			<nail x="-654" y="-42"/>
		</transition>
		<transition id="id71">
			<source ref="id58"/>
			<target ref="id59"/>
			<label kind="guard" x="-714" y="-153">x == STEP_TIME</label>
			<label kind="assignment" x="-714" y="-136">step(), x = 0</label>
			<nail x="-654" y="-110"/>
		</transition>
		<transition id="id72">
			<source ref="id57"/>
			<target ref="id58"/>
			<label kind="synchronisation" x="-1011" y="-93">init_done?</label>
			<label kind="assignment" x="-1003" y="-76">enter()</label>
		</transition>
	</template>
	<system>//system Initializer, Civilian;

system Initializer, First_Responder, Civilian, Drone;
</system>
	<queries>
		<query>
			<formula/>
			<comment>------- Mandatory Properties -------</comment>
		</query>
		<query>
			<formula>Pr[&lt;=10000] (&lt;&gt; ( saved &gt;= N_save and total_time &lt;= T_scs ))</formula>
			<comment>Q1: it is possible for a percentage N_save of all civilians to reach a safe state within time T_scs</comment>
			<result outcome="success" type="interval" value="‚â• 0.950056 (95% CI)" timestamp="2024-07-13 11:29:31 +0200">
				<details>‚â• 0.950056 (95% CI)</details>
				<plot title="Probability Density Distribution" xaxis="run duration in time" yaxis="probability density">
					<series title="density" type="b(0.000000)" color="0x0000ff" encoding="csv">2.0,4.503599627370496E15
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">2.0,0.0
2.0,4.503599627370496E15
					</series>
					<comment>Parameters: Œ±=0.05, Œµ=0.05, bucket width=2.2204e-16, bucket count=1
Runs: 72 in total, 72 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [2, 2]
Mean estimate of displayed sample: ‚âà 2</comment>
				</plot>
				<plot title="Probability Density Confidence Intervals" xaxis="run duration in time" yaxis="probability density">
					<series title="upper limit" type="b(0.000000)" color="0xa0a0ff" encoding="csv">2.0,1.0
					</series>
					<series title="lower limit" type="b(0.000000)" color="0x0000ff" encoding="csv">2.0,0.9500559162941453
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">2.0,0.0
2.0,4.503599627370496E15
					</series>
					<comment>Parameters: Œ±=0.05, Œµ=0.05, bucket width=2.2204e-16, bucket count=1
Runs: 72 in total, 72 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [2, 2]
Mean estimate of displayed sample: ‚âà 2</comment>
				</plot>
				<plot title="Probability Distribution" xaxis="run duration in time" yaxis="probability">
					<series title="probability" type="b(0.000000)" color="0x0000ff" encoding="csv">2.0,1.0
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">2.0,0.0
2.0,1.0
					</series>
					<comment>Parameters: Œ±=0.05, Œµ=0.05, bucket width=2.2204e-16, bucket count=1
Runs: 72 in total, 72 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [2, 2]
Mean estimate of displayed sample: ‚âà 2</comment>
				</plot>
				<plot title="Probability Confidence Intervals" xaxis="run duration in time" yaxis="probability">
					<series title="upper limit" type="b(0.000000)" color="0xa0a0ff" encoding="csv">2.0,1.0
					</series>
					<series title="lower limit" type="b(0.000000)" color="0x0000ff" encoding="csv">2.0,0.9500559162941453
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">2.0,0.0
2.0,1.0
					</series>
					<comment>Parameters: Œ±=0.05, Œµ=0.05, bucket width=2.2204e-16, bucket count=1
Runs: 72 in total, 72 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [2, 2]
Mean estimate of displayed sample: ‚âà 2</comment>
				</plot>
				<plot title="Cumulative Probability Distribution" xaxis="run duration in time" yaxis="probability">
					<series title="cumulative" type="l" color="0x000000" encoding="csv">2.0,0.0
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">2.0,0.0
2.0,1.0
					</series>
					<comment>Parameters: Œ±=0.05, Œµ=0.05, bucket width=2.2204e-16, bucket count=1
Runs: 72 in total, 72 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [2, 2]
Mean estimate of displayed sample: ‚âà 2</comment>
				</plot>
				<plot title="Cumulative Probability Confidence Intervals" xaxis="run duration in time" yaxis="probability">
					<series title="upper limit" type="k" color="0x0000dd" encoding="csv">2.0,0.04994408370585468
					</series>
					<series title="lower limit" type="k" color="0xdd0000" encoding="csv">2.0,0.0
					</series>
					<series title="cumulative" type="l" color="0x000000" encoding="csv">2.0,0.0
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">2.0,0.0
2.0,1.0
					</series>
					<comment>Parameters: Œ±=0.05, Œµ=0.05, bucket width=2.2204e-16, bucket count=1
Runs: 72 in total, 72 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [2, 2]
Mean estimate of displayed sample: ‚âà 2</comment>
				</plot>
				<plot title="Frequency Histogram" xaxis="run duration in time" yaxis="count">
					<series title="count" type="b(0.000000)" color="0x0000ff" encoding="csv">2.0,72.0
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">2.0,0.0
2.0,72.0
					</series>
					<comment>Parameters: Œ±=0.05, Œµ=0.05, bucket width=2.2204e-16, bucket count=1
Runs: 72 in total, 72 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [2, 2]
Mean estimate of displayed sample: ‚âà 2</comment>
				</plot>
			</result>
		</query>
		<query>
			<formula>Pr[&lt;=10000] ([]( (total_time == T_scs) imply (saved &gt;= N_save) ))</formula>
			<comment>Q2: a percentage N_save of all civilians is always guaranteed to reach a safe state within time T_scs</comment>
			<result outcome="success" type="interval" value="‚â§ 0.0499441 (95% CI)" timestamp="2024-07-13 11:34:45 +0200">
				<details>‚â§ 0.0499441 (95% CI)</details>
			</result>
		</query>
		<query>
			<formula/>
			<comment>------- Additional Properties -------</comment>
		</query>
		<query>
			<formula>Pr[&lt;=10000] ( [] (
	((forall (i:civ_t) Civilian(i).Dead or Civilian(i).Safe) &amp;&amp;
	 (forall (j:fr_t) First_Responder(j).Finished) &amp;&amp;
	 (forall (k:dr_t) Drone(k).Finish))
 		imply ((saved+casualties) == N_CIVILIANS)))</formula>
			<comment>System in deadlock only when a scenario is finished (every civilian is either safe or dead)</comment>
			<result outcome="success" type="interval" value="‚â• 0.950056 (95% CI)" timestamp="2024-07-13 11:44:21 +0200">
				<details>‚â• 0.950056 (95% CI)</details>
			</result>
		</query>
		<query>
			<formula>Pr[&lt;=10000] ([] ((sum (i:civ_t) Civilian(i).Danger || Civilian(i).Helped) &gt;= (sum (j:civ_t) Civilian(j).Helping || Civilian(j).ZR_Received) + (sum(k:fr_t) First_Responder(k).FR_Received || First_Responder(k).Helping) )) </formula>
			<comment>Number of civilians in danger always more or equal to number of busy FRs plus number of busy ZRs</comment>
			<result outcome="success" type="interval" value="‚â• 0.950056 (95% CI)" timestamp="2024-07-13 11:23:21 +0200">
				<details>‚â• 0.950056 (95% CI)</details>
			</result>
		</query>
		<query>
			<formula>Pr[&lt;=10000] (&lt;&gt;((saved+casualties) == N_CIVILIANS))</formula>
			<comment>saved + casualties eventually equal to N_CIVILIANS</comment>
			<result outcome="success" type="interval" value="‚â• 0.950056 (95% CI)" timestamp="2024-07-13 11:22:26 +0200">
				<details>‚â• 0.950056 (95% CI)</details>
				<plot title="Probability Density Distribution" xaxis="run duration in time" yaxis="probability density">
					<series title="density" type="b(0.222222)" color="0x0000ff" encoding="csv">10.0,2.5625
10.222222222222221,0.0
10.444444444444445,0.0
10.666666666666666,0.0
10.88888888888889,0.0
11.11111111111111,0.0
11.333333333333334,0.0
11.555555555555555,0.0
11.777777777777779,0.0
12.0,1.9375
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">10.86111111111111,0.0
10.86111111111111,2.5625
					</series>
					<comment>Parameters: Œ±=0.05, Œµ=0.05, bucket width=0.22222, bucket count=10
Runs: 72 in total, 72 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [10, 12]
Mean estimate of displayed sample: 10.861 ¬± 0.23434 (95% CI)</comment>
				</plot>
				<plot title="Probability Density Confidence Intervals" xaxis="run duration in time" yaxis="probability density">
					<series title="upper limit" type="b(0.222222)" color="0xa0a0ff" encoding="csv">10.0,0.6856593477559774
10.222222222222221,0.04994408370585468
10.444444444444445,0.04994408370585468
10.666666666666666,0.04994408370585468
10.88888888888889,0.04994408370585468
11.11111111111111,0.04994408370585468
11.333333333333334,0.04994408370585468
11.555555555555555,0.04994408370585468
11.777777777777779,0.04994408370585468
12.0,0.5526642096839557
					</series>
					<series title="lower limit" type="b(0.222222)" color="0x0000ff" encoding="csv">10.0,0.4473357903160443
10.222222222222221,0.0
10.444444444444445,0.0
10.666666666666666,0.0
10.88888888888889,0.0
11.11111111111111,0.0
11.333333333333334,0.0
11.555555555555555,0.0
11.777777777777779,0.0
12.0,0.3143406522440227
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">10.86111111111111,0.0
10.86111111111111,3.0854670649018985
					</series>
					<comment>Parameters: Œ±=0.05, Œµ=0.05, bucket width=0.22222, bucket count=10
Runs: 72 in total, 72 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [10, 12]
Mean estimate of displayed sample: 10.861 ¬± 0.23434 (95% CI)</comment>
				</plot>
				<plot title="Probability Distribution" xaxis="run duration in time" yaxis="probability">
					<series title="probability" type="b(0.222222)" color="0x0000ff" encoding="csv">10.0,0.5694444444444444
10.222222222222221,0.0
10.444444444444445,0.0
10.666666666666666,0.0
10.88888888888889,0.0
11.11111111111111,0.0
11.333333333333334,0.0
11.555555555555555,0.0
11.777777777777779,0.0
12.0,0.4305555555555556
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">10.86111111111111,0.0
10.86111111111111,0.5694444444444444
					</series>
					<comment>Parameters: Œ±=0.05, Œµ=0.05, bucket width=0.22222, bucket count=10
Runs: 72 in total, 72 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [10, 12]
Mean estimate of displayed sample: 10.861 ¬± 0.23434 (95% CI)</comment>
				</plot>
				<plot title="Probability Confidence Intervals" xaxis="run duration in time" yaxis="probability">
					<series title="upper limit" type="b(0.222222)" color="0xa0a0ff" encoding="csv">10.0,0.6856593477559774
10.222222222222221,0.04994408370585468
10.444444444444445,0.04994408370585468
10.666666666666666,0.04994408370585468
10.88888888888889,0.04994408370585468
11.11111111111111,0.04994408370585468
11.333333333333334,0.04994408370585468
11.555555555555555,0.04994408370585468
11.777777777777779,0.04994408370585468
12.0,0.5526642096839557
					</series>
					<series title="lower limit" type="b(0.222222)" color="0x0000ff" encoding="csv">10.0,0.4473357903160443
10.222222222222221,0.0
10.444444444444445,0.0
10.666666666666666,0.0
10.88888888888889,0.0
11.11111111111111,0.0
11.333333333333334,0.0
11.555555555555555,0.0
11.777777777777779,0.0
12.0,0.3143406522440227
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">10.86111111111111,0.0
10.86111111111111,0.6856593477559774
					</series>
					<comment>Parameters: Œ±=0.05, Œµ=0.05, bucket width=0.22222, bucket count=10
Runs: 72 in total, 72 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [10, 12]
Mean estimate of displayed sample: 10.861 ¬± 0.23434 (95% CI)</comment>
				</plot>
				<plot title="Cumulative Probability Distribution" xaxis="run duration in time" yaxis="probability">
					<series title="cumulative" type="l" color="0x000000" encoding="csv">10.0,0.0
10.222222222222221,0.5694444444444444
10.444444444444445,0.5694444444444444
10.666666666666666,0.5694444444444444
10.88888888888889,0.5694444444444444
11.11111111111111,0.5694444444444444
11.333333333333334,0.5694444444444444
11.555555555555555,0.5694444444444444
11.777777777777779,0.5694444444444444
12.0,0.5694444444444444
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">10.86111111111111,0.0
10.86111111111111,1.0
					</series>
					<comment>Parameters: Œ±=0.05, Œµ=0.05, bucket width=0.22222, bucket count=10
Runs: 72 in total, 72 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [10, 12]
Mean estimate of displayed sample: 10.861 ¬± 0.23434 (95% CI)</comment>
				</plot>
				<plot title="Cumulative Probability Confidence Intervals" xaxis="run duration in time" yaxis="probability">
					<series title="upper limit" type="k" color="0x0000dd" encoding="csv">10.0,0.04994408370585468
10.222222222222221,0.6856593477559774
10.444444444444445,0.6856593477559774
10.666666666666666,0.6856593477559774
10.88888888888889,0.6856593477559774
11.11111111111111,0.6856593477559774
11.333333333333334,0.6856593477559774
11.555555555555555,0.6856593477559774
11.777777777777779,0.6856593477559774
12.0,0.6856593477559774
					</series>
					<series title="lower limit" type="k" color="0xdd0000" encoding="csv">10.0,0.0
10.222222222222221,0.4473357903160443
10.444444444444445,0.4473357903160443
10.666666666666666,0.4473357903160443
10.88888888888889,0.4473357903160443
11.11111111111111,0.4473357903160443
11.333333333333334,0.4473357903160443
11.555555555555555,0.4473357903160443
11.777777777777779,0.4473357903160443
12.0,0.4473357903160443
					</series>
					<series title="cumulative" type="l" color="0x000000" encoding="csv">10.0,0.0
10.222222222222221,0.5694444444444444
10.444444444444445,0.5694444444444444
10.666666666666666,0.5694444444444444
10.88888888888889,0.5694444444444444
11.11111111111111,0.5694444444444444
11.333333333333334,0.5694444444444444
11.555555555555555,0.5694444444444444
11.777777777777779,0.5694444444444444
12.0,0.5694444444444444
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">10.86111111111111,0.0
10.86111111111111,1.0
					</series>
					<comment>Parameters: Œ±=0.05, Œµ=0.05, bucket width=0.22222, bucket count=10
Runs: 72 in total, 72 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [10, 12]
Mean estimate of displayed sample: 10.861 ¬± 0.23434 (95% CI)</comment>
				</plot>
				<plot title="Frequency Histogram" xaxis="run duration in time" yaxis="count">
					<series title="count" type="b(0.222222)" color="0x0000ff" encoding="csv">10.0,41.0
10.222222222222221,0.0
10.444444444444445,0.0
10.666666666666666,0.0
10.88888888888889,0.0
11.11111111111111,0.0
11.333333333333334,0.0
11.555555555555555,0.0
11.777777777777779,0.0
12.0,31.0
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">10.86111111111111,0.0
10.86111111111111,41.0
					</series>
					<comment>Parameters: Œ±=0.05, Œµ=0.05, bucket width=0.22222, bucket count=10
Runs: 72 in total, 72 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [10, 12]
Mean estimate of displayed sample: 10.861 ¬± 0.23434 (95% CI)</comment>
				</plot>
			</result>
		</query>
		<query>
			<formula>Pr[&lt;=10000] ( [] ((sum (i:civ_t) Civilian(i).Helped) ) == ( (sum (j:civ_t) Civilian(j).Helping) + (sum(k:fr_t) First_Responder(k).Helping)) )</formula>
			<comment>Number of civilians in helping state always equal to FR busy + ZR busy</comment>
			<result outcome="success" type="interval" value="‚â• 0.950056 (95% CI)" timestamp="2024-07-13 11:22:48 +0200">
				<details>‚â• 0.950056 (95% CI)</details>
			</result>
		</query>
	</queries>
</nta>
