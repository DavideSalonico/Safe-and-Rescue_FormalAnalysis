<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.6//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_6.dtd'>
<nta>
	<declaration>// Place global declarations here.
const int GRID_LENGTH = 10;
const int GRID_HEIGHT = 10;
const int N_EXITS = 6;
const int N_FIRES = 15;
const int N_DRONES = 2;
const int N_CIVILIANS = 6;
const int N_FIRST_RESPONDERS = 2;
const int T_ZR = 4;                      // Time that a Zero Responder needs to help someone
const int T_FR = 3;                      // Time that a First Responder needs to help someone
const int STEP_TIME = 1;                 // Time to step
const int T_V = 10;                      // Time before a civilian is supposed to die
const int N_V = 2;                       // Drones' visibility range
const int MAX_TRAJ = 8;                  // Max trajectory length

// TODO: gestire queste variabili e capire come proporzionarle
// Const for model checking
const int N_save = 0;                    // (N% = N_save/N_CIVILIANS) percentage of all civilians to reach a safe state
const int T_scs = 0;                     // Time to check properties

// Global types
typedef int [0, N_DRONES-1] dr_t;
typedef int [0, N_FIRST_RESPONDERS-1] fr_t;
typedef int [0, N_CIVILIANS-1] civ_t;
typedef struct { int r; int c; } pos_t;

// Map constants
const int OUTSIDE      = -1;
const int NONE         =  0;
const int EXIT         =  1;             // Exit
const int FIRE         =  2;             // Fire
const int SURVIVOR     =  3;             // Survivor (civilian not in danger)
const int FIRST_R      =  4;             // First Responder not busy
const int FIRST_R_BUSY =  8;             // First Responder busy helping someone
const int ZERO_R       =  5;             // Zero Responder 
const int ASSISTED     =  6;             // Civilian in danger being assisted
const int NEED_ASSIST  =  7;             // Civilian in danger in need for assistance
const int CONTACTING   =  9;             // survivor busy calling a first responder/waiting for him to rescue someone in danger

const pos_t OUT_OF_MAP = {-1, -1};       // Position to declare someone has exited the map (either dead or alive)

const int MAX_INT =  32767; //from doc

// Channels
broadcast chan init_done;
chan helping[N_CIVILIANS];
urgent chan FR_help_req[N_FIRST_RESPONDERS];
broadcast chan saved_by_FR[N_CIVILIANS];
broadcast chan saved_by_ZR[N_CIVILIANS];
broadcast chan civ_dead[N_CIVILIANS]; 
urgent chan call_zero_resp[N_CIVILIANS];
urgent chan call_first_resp[N_CIVILIANS];


// Global variables
int casualties = 0;
int saved = 0;

// Grid layout
int grid[GRID_LENGTH][GRID_HEIGHT] = {{0, 0, 1, 1, 1, 2, 2, 0, 0, 0},
                                      {0, 0, 0, 0, 0, 2, 2, 0, 0, 0},
                                      {0, 0, 0, 0, 0, 2, 2, 0, 0, 0},
                                      {0, 0, 4, 0, 0, 7, 0, 0, 0, 0},
                                      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                      {1, 0, 0, 3, 0, 0, 3, 0, 0, 0},
                                      {1, 0, 0, 0, 3, 0, 4, 0, 3, 0},
                                      {1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                      {0, 0, 2, 2, 0, 0, 0, 0, 0, 0},
                                      {0, 0, 2, 2, 2, 2, 0, 2, 7, 0}};

// Global arrays
pos_t exits[N_EXITS];
pos_t fires[N_FIRES];
pos_t pos_FRs[N_FIRST_RESPONDERS];
pos_t pos_civilians[N_CIVILIANS];
pos_t drone_trajectories[N_DRONES][MAX_TRAJ] = {{{4, 6}, {3, 6}, {3, 5}, {4, 5}, {4, 6}, {3, 6}, {3, 5}, {4, 5}},
                                                {{6, 3}, {6, 4}, {6, 5}, {5, 5}, {5, 4}, {4, 4}, OUT_OF_MAP, OUT_OF_MAP}};
/*pos_t fr_trajectories[N_FIRST_RESPONDERS][MAX_TRAJ] = {{{1, 8}, {1, 7}, {2, 7}, {3, 7}, {3, 6}, {3, 5}, {3, 4}, {2, 4}},
                                                       {{4, 3}, {4, 2}, {4, 1}, {4, 0}, {3, 0}, {2, 0}, {1, 0}, {0, 0}}};
*/
int drone_traj_lengths[N_DRONES] = {4, 6};
int fr_traj_lenghts[N_FIRST_RESPONDERS] = { 8 , 4 };  
pos_t movements[8] = {
        {-1, 0},  // Move up
        {-1, 1},  // Move up-right diagonal
        {0, 1},   // Move right
        {1, 1},   // Move down-right diagonal
        {1, 0},   // Move down
        {1, -1},  // Move down-left diagonal
        {0, -1},  // Move left
        {-1, -1}  // Move up-left diagonal
    };

// Exits, Humans, Drones can have arbitrary positions.
// TODO: check if just a position is ok or we need an array
pos_t pos_to_save = OUT_OF_MAP;
int caller_id = -1;

/* GLOBAL UTILITY FUNCTIONS ****************/

/*
 * Get the value of a cell of the map given its pos_t coordinates.
 */
int cell(pos_t p) {
    if (p.r &gt;= 0 &amp;&amp; p.r &lt; GRID_LENGTH &amp;&amp; p.c &gt;= 0 &amp;&amp; p.c &lt; GRID_HEIGHT){
        return grid[p.r][p.c];
    } else {
        return OUTSIDE;
    }
}

/*
 * Get the value of a cell of the map given its int coordinates.
 */
int cell_int(int x, int y) {
    if (x &gt;= 0 &amp;&amp; x &lt; GRID_LENGTH &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; GRID_HEIGHT){
        return grid[x][y];
    } else {
        return OUTSIDE;
    }
}

/*
 * Check whether a cell of the map is occupied or not.
 */
bool cell_is_free(pos_t p) {
    return cell(p) == NONE;
}

/*
 * Compute distance from two positions in the grid (NO diagonal moves allowed).
 */
int dist2(pos_t src, pos_t dest){
    int x_dist = abs(dest.r - src.r);
    int y_dist = abs(dest.c - src.c);
    return x_dist + y_dist;
}

/*
 * Compute max between two integers.
 */ 
int max(int a, int b){
    return a &gt;= b ? a : b;
}


/*
 * Compute distance from two positions in the grid (diagonal moves allowed).
 */
int dist(pos_t src, pos_t dest){
    int x_dist = abs(dest.r - src.r);
    int y_dist = abs(dest.c - src.c);
    return max(x_dist, y_dist);
}

/*
 * Move civilian from src to dest in the map (when calling the function cell(src) must be SURVIVOR)
 */ 
void move_civ(pos_t src, pos_t dest){
    grid[src.r][src.c] = NONE;
    grid[dest.r][dest.c] = SURVIVOR;
}

/*
 * Move first responder from src to dest in the map (when calling the function cell(src) must be FIRST_R)
 */ 
void move_fr(pos_t src, pos_t dest){
    grid[src.r][src.c] = NONE;
    grid[dest.r][dest.c] = FIRST_R;
}

/*
 * Retrieve index of a civilian from its position
 */
int get_civ_idx(pos_t pos){
    int i;
    for(i = 0; i &lt; N_CIVILIANS; i++){
        if(pos_civilians[i] == pos) return i;
    }
    return -1;
}

pos_t randomPos(int i, pos_t pos) {
    // Get the movement corresponding to the input i
    pos_t move = movements[i], new_pos;
    
    // Calculate the new position
    
    new_pos.r = pos.r + move.r;
    new_pos.c = pos.c + move.c;
    
    return new_pos;
}

/*
 * Get the next cell to go to reach the objective
 */
void getNextCellToGoTo(pos_t &amp;pos1, pos_t &amp;pos2, pos_t &amp;ret_pos){
    int x_move, y_move;
    if(pos1.r &gt; pos2.r){
        y_move = -1;
    } else if(pos1.r = pos2.r){
        y_move = 0; // No vertical movement
    } else{
        y_move = 1;
    }
    
    if(pos1.c &gt; pos2.c){
        x_move = -1;
    } else if(pos1.c = pos2.c){
        x_move = 0; // No horizontal movement
    } else{
        x_move = 1;
    }

    ret_pos.r = pos1.r + y_move;
    ret_pos.c = pos1.c + x_move;
}

/*
 * Check if cell is free
 */
bool isCellFree(pos_t p) {
    if (cell(p) == NONE){
        return true;
    }else{
        return false;
    }
}</declaration>
	<template>
		<name>First_Responder</name>
		<parameter>fr_t p_id</parameter>
		<declaration>const int FREE = 0;
const int NEAR_DANGER = 1;
const int CALLED = 2;

clock x;
int id, k;                           // Id and trajectory index
pos_t pos;                           // Position in the map
pos_t trajectory[MAX_TRAJ];          // Trajectory
int traj_l;                          // Trajectory length
int status = FREE;                   // Status
int time_to_assist = -1;             // Time to rescue a civilian       
int civ_id;                          // Id of the civilian rescue


/*
 * Check if near a Civilian in danger
 */
bool nearCivilianInDanger() {
    int i, j;
    pos_t civ_pos;
    for (j=-1; j&lt;=1; j++) {
        for (i=-1; i&lt;=1; i++) {
            if (pos.r+i &gt;= 0 &amp;&amp; pos.c+j &gt;= 0 &amp;&amp; pos.r+i &lt; GRID_HEIGHT &amp;&amp; pos.c+j &lt; GRID_LENGTH &amp;&amp; cell_int(pos.r+i, pos.c+j) == NEED_ASSIST){
                civ_pos.r = pos.r+i;
                civ_pos.c = pos.c+j;
                civ_id = get_civ_idx(civ_pos);
                return true;
            }
        }
    }
    return false;
}

/*
 * Enter the map at the entry point.
 */
void enter() {
    id = p_id;
    //pos.r = pos_FRs[id].r;
    //pos.c = pos_FRs[id].c;
    //trajectory = fr_trajectories[id];
    //pos = trajectory[k];
    //k = 0;
    //traj_l = fr_traj_lenghts[id];
    pos = pos_FRs[id];
    if (nearCivilianInDanger()) {
        status = NEAR_DANGER;
    }
}

/*
 * Calculate total time to assist a civilian in danger
 */
void timeToAssist() {
    if (status == NEAR_DANGER) {
        time_to_assist = T_FR;
    } else {
        time_to_assist = T_FR + dist(pos, pos_civilians[civ_id]) - 1;
    }
}


/*
 * Update global position Array
 */
void update_FR_pos() {
    pos_FRs[id] = pos;
}

/*
 * Get closer fire
 */
int getCloserFire(pos_t pos){
    int i, min = MAX_INT;
    int closer_fire = -1;
    for(i=0; i &lt; N_EXITS; i++){
        if(dist(fires[i], pos) &lt; min){
            min = dist(fires[i], pos);
            closer_fire = i;
        }
    }
    return closer_fire;
}

// TODO: da sistemare, aggiornare posizione se gi√† vicino ad un fuoco
/*
 * Step in fire direction, greater probability to find a civilian to help
 */
void step_fire(){
    pos_t closest_fire = fires[getCloserFire(pos)], next = OUT_OF_MAP;
    if (pos != closest_fire) {
        getNextCellToGoTo(pos, closest_fire, next);
    } else {
        next = pos;
    }
    if(isCellFree(next)){
        grid[pos.r][pos.c] = NONE;
        pos = next;
        grid[pos.r][pos.c] = FIRST_R;
    }
    update_FR_pos();
}


// TODO: change to put isCellFree and moveFr  
void step(int step_dir) {
    // Random policy
    bool valid_step_found = false;
    int tries = 0;
    while (valid_step_found == false &amp;&amp; tries &lt; 8) {
        if (step_dir == 0 &amp;&amp; pos.r+1 &lt; GRID_HEIGHT &amp;&amp; cell_int(pos.r+1, pos.c) == NONE) { // Move down
            grid[pos.r][pos.c] = NONE;
            pos.r++;
            grid[pos.r][pos.c] = FIRST_R;
            valid_step_found = true;
        }
        if (step_dir == 1 &amp;&amp; pos.r-1 &gt;= 0 &amp;&amp; cell_int(pos.r-1, pos.c) == NONE) { // Move up
            grid[pos.r][pos.c] = NONE;
            pos.r--;
            grid[pos.r][pos.c] = FIRST_R;
            valid_step_found = true;
        }
        if (step_dir == 2 &amp;&amp; pos.c-1 &gt;= 0 &amp;&amp; cell_int(pos.r, pos.c-1) == NONE) { // Move left
            grid[pos.r][pos.c] = NONE;
            pos.c--;
            grid[pos.r][pos.c] = FIRST_R;
            valid_step_found = true;
        }
        if (step_dir == 3 &amp;&amp; pos.c+1 &lt; GRID_LENGTH &amp;&amp; cell_int(pos.r, pos.c+1) == NONE) { // Move right
            grid[pos.r][pos.c] = NONE;
            pos.c++;
            grid[pos.r][pos.c] = FIRST_R;
            valid_step_found = true;
        }
        if (step_dir == 4 &amp;&amp; pos.r+1 &lt; GRID_HEIGHT &amp;&amp; pos.c-1 &gt;= 0 &amp;&amp; cell_int(pos.r+1, pos.c-1) == NONE) { // Move down-left
            grid[pos.r][pos.c] = NONE;
            pos.r++;
            pos.c--;
            grid[pos.r][pos.c] = FIRST_R;
            valid_step_found = true;
        }
        if (step_dir == 5 &amp;&amp; pos.r+1 &lt; GRID_HEIGHT &amp;&amp; pos.c+1 &lt; GRID_LENGTH &amp;&amp; cell_int(pos.r+1, pos.c+1) == NONE) { // Move down-right
            grid[pos.r][pos.c] = NONE;
            pos.r++;
            pos.c++;
            grid[pos.r][pos.c] = FIRST_R;
            valid_step_found = true;
        }
        if (step_dir == 6 &amp;&amp; pos.r-1 &gt;= 0 &amp;&amp; pos.c-1 &gt;= 0 &amp;&amp; cell_int(pos.r-1, pos.c-1) == NONE) { // Move up-left
            grid[pos.r][pos.c] = NONE;
            pos.r--;
            pos.c--;
            grid[pos.r][pos.c] = FIRST_R;
            valid_step_found = true;
        }
        if (step_dir == 7 &amp;&amp; pos.r-1 &gt;= 0 &amp;&amp; pos.c+1 &lt; GRID_LENGTH &amp;&amp; cell_int(pos.r-1, pos.c+1) == NONE) { // Move up-right
            grid[pos.r][pos.c] = NONE;
            pos.r--;
            pos.c++;
            grid[pos.r][pos.c] = FIRST_R;
            valid_step_found = true;
        }
        step_dir = (step_dir+1) % 8;
        if (valid_step_found == false) {
            tries++;
        }
    }
    update_FR_pos();
    
    if (nearCivilianInDanger()) {
        status = NEAR_DANGER;
    }
}


// TODO capire come gestire la precenza tra near danger e la ricezione della richiesta di aiuto: dovrebbe essere l'ordine di dichiarazione dei chan
/*
 * Update global grid by setting FR busy or not
 */
void updateGrid() {
    if (grid[pos.r][pos.c] == FIRST_R) {
        grid[pos.r][pos.c] = FIRST_R_BUSY;
    } else if (grid[pos.r][pos.c] == FIRST_R_BUSY) {
        grid[pos.r][pos.c] = FIRST_R;
    }
}

// TODO: Change it in order to properly set the pos_to_save
/*
 * Step function that follows a specified trajectory. Updates grid and global FR position array and checks new status
 */
/*
void step() {
    k = (k+1) % traj_l;
    if(isCellFree(trajectory[k])){
        grid[pos.r][pos.c] = NONE;
        pos = trajectory[k];
        grid[pos.r][pos.c] = FIRST_R;   
    } else {
        k = k - 1;
    }
    update_FR_pos();
    if (nearCivilianInDanger()) {
        status = NEAR_DANGER;
    }
}
*/
/*
 * Update when a help request is received
 */
void helpReqReceived() {
    status = CALLED;
    updateGrid();
    civ_id = get_civ_idx(pos_to_save);
    pos_to_save = OUT_OF_MAP;
}

/*
 * Update when starting to help someone near
 */
void nearDanger() {
    x = 0;
    updateGrid();
    timeToAssist();
    pos_to_save = OUT_OF_MAP;
}

/*
 * Update when returning to Moving state
 */
void retToMove() {
    status = FREE;
    x = 0;
    updateGrid();
    time_to_assist = -1;
}</declaration>
		<location id="id0" x="-628" y="-93">
		</location>
		<location id="id1" x="-366" y="68">
			<name x="-433" y="42">Moving</name>
			<label kind="invariant" x="-484" y="76">x&lt;=STEP_TIME</label>
		</location>
		<location id="id2" x="118" y="68">
			<name x="136" y="42">Helping</name>
			<label kind="invariant" x="127" y="76">x&lt;=time_to_assist</label>
		</location>
		<location id="id3" x="-119" y="68">
			<committed/>
		</location>
		<location id="id4" x="-365" y="-93">
			<committed/>
		</location>
		<init ref="id0"/>
		<transition id="id5">
			<source ref="id4"/>
			<target ref="id1"/>
			<label kind="guard" x="-323" y="-25">status == FREE</label>
			<nail x="-331" y="-17"/>
		</transition>
		<transition id="id6">
			<source ref="id2"/>
			<target ref="id1"/>
			<label kind="synchronisation" x="-196" y="263">civ_dead[civ_id]?</label>
			<label kind="assignment" x="-170" y="289">retToMove()</label>
			<nail x="118" y="288"/>
			<nail x="-366" y="288"/>
		</transition>
		<transition id="id7">
			<source ref="id3"/>
			<target ref="id2"/>
			<label kind="synchronisation" x="-60" y="51">helping[civ_id]!</label>
			<label kind="assignment" x="-60" y="68">x=0, 
timeToAssist()</label>
		</transition>
		<transition id="id8">
			<source ref="id1"/>
			<target ref="id3"/>
			<label kind="synchronisation" x="-298" y="51">FR_help_req[id]?</label>
			<label kind="assignment" x="-306" y="68">helpReqReceived()</label>
		</transition>
		<transition id="id9">
			<source ref="id4"/>
			<target ref="id2"/>
			<label kind="guard" x="-127" y="-153">status == NEAR_DANGER</label>
			<label kind="synchronisation" x="-102" y="-136">helping[civ_id]!</label>
			<label kind="assignment" x="-85" y="-119">nearDanger()</label>
			<nail x="119" y="-93"/>
		</transition>
		<transition id="id10">
			<source ref="id1"/>
			<target ref="id4"/>
			<label kind="select" x="-569" y="-42">step_dir: int[0, 7]</label>
			<label kind="guard" x="-543" y="-25">x == STEP_TIME</label>
			<label kind="assignment" x="-569" y="-8">step(step_dir), x=0</label>
			<nail x="-399" y="-17"/>
		</transition>
		<transition id="id11">
			<source ref="id2"/>
			<target ref="id1"/>
			<label kind="guard" x="-196" y="144">x == time_to_assist</label>
			<label kind="synchronisation" x="-196" y="161">saved_by_FR[civ_id]!</label>
			<label kind="assignment" x="-162" y="186">retToMove()</label>
			<nail x="118" y="186"/>
			<nail x="-366" y="186"/>
		</transition>
		<transition id="id12">
			<source ref="id0"/>
			<target ref="id4"/>
			<label kind="synchronisation" x="-552" y="-136">init_done?</label>
			<label kind="assignment" x="-535" y="-119">enter()</label>
		</transition>
	</template>
	<template>
		<name>Civilian</name>
		<parameter>civ_t p_id</parameter>
		<declaration>const int SAVED = 1;
const int DANGER = 2;
const int STEP = 3;
const int ZERO_RESP = 4;
const int CIV_ASSISTED = 5;
const int DEAD = 6;
const int BUSY = 7;

clock x;
int id;                    // Id
pos_t pos;                 // Position
int status = 0;            // Status
int timeToAssist = -1;     // Time to rescue another civilian
int civ_need_id;           // Id of the civilian to help (ZR case)
int fr_id;                 // Id of the FR to call

/*
 * Golden rule to check:
 * for every transition check clock update (if necessary), internal status update, grid update
 */

// TODO: clean pos_to_save
// TODO: occhio alla direzione verso le uscite
// TODO: togliere ridondanza sulla posizione
/*
 * Get closer exit
 */
int getCloserExit(pos_t pos){
    int i, min = MAX_INT;
    int closer_exit = -1;
    for(i=0; i &lt; N_EXITS; i++){
        if(dist(exits[i], pos) &lt; min){
            min = dist(exits[i], pos);
            closer_exit = i;
        }
    }

    return closer_exit;
}

/*
 * Check whether a cell of the map is occupied or not.
bool isCellFreeCiv(pos_t p) {
    if (cell(p) == NONE || cell(p) == EXIT){
        return true;
    }else{
        return false;
    }
}
 */

// KEEP THIS ORDER IN THE CHECKS !!!
/*
 * Check civilian status
 */
int computeStatus(int px, int py){
     // check Exit
    int i, j;
    for(i = -1; i &lt; 2; i++){
        for(j = -1; j &lt; 2; j++){
            if(cell_int(px + i, py + j) == EXIT) return SAVED;
        }
    }
    // check Fire 
    for(i = -1; i &lt; 2; i++){
        for(j = -1; j &lt; 2; j++){
            if(cell_int(px + i, py + j) == FIRE) return DANGER;
        }
    }
    return STEP;
}


void step(int step_dir) {
    // Random policy
    bool valid_step_found = false;
    int tries = 0;
    while (valid_step_found == false &amp;&amp; tries &lt; 8) {
        if (step_dir == 0 &amp;&amp; pos.r+1 &lt; GRID_HEIGHT &amp;&amp; cell_int(pos.r+1, pos.c) == NONE) { // Move down
            grid[pos.r][pos.c] = NONE;
            pos.r++;
            grid[pos.r][pos.c] = SURVIVOR;
            valid_step_found = true;
        }
        if (step_dir == 1 &amp;&amp; pos.r-1 &gt;= 0 &amp;&amp; cell_int(pos.r-1, pos.c) == NONE) { // Move up
            grid[pos.r][pos.c] = NONE;
            pos.r--;
            grid[pos.r][pos.c] = SURVIVOR;
            valid_step_found = true;
        }
        if (step_dir == 2 &amp;&amp; pos.c-1 &gt;= 0 &amp;&amp; cell_int(pos.r, pos.c-1) == NONE) { // Move left
            grid[pos.r][pos.c] = NONE;
            pos.c--;
            grid[pos.r][pos.c] = SURVIVOR;
            valid_step_found = true;
        }
        if (step_dir == 3 &amp;&amp; pos.c+1 &lt; GRID_LENGTH &amp;&amp; cell_int(pos.r, pos.c+1) == NONE) { // Move right
            grid[pos.r][pos.c] = NONE;
            pos.c++;
            grid[pos.r][pos.c] = SURVIVOR;
            valid_step_found = true;
        }
        if (step_dir == 4 &amp;&amp; pos.r+1 &lt; GRID_HEIGHT &amp;&amp; pos.c-1 &gt;= 0 &amp;&amp; cell_int(pos.r+1, pos.c-1) == NONE) { // Move down-left
            grid[pos.r][pos.c] = NONE;
            pos.r++;
            pos.c--;
            grid[pos.r][pos.c] = SURVIVOR;
            valid_step_found = true;
        }
        if (step_dir == 5 &amp;&amp; pos.r+1 &lt; GRID_HEIGHT &amp;&amp; pos.c+1 &lt; GRID_LENGTH &amp;&amp; cell_int(pos.r+1, pos.c+1) == NONE) { // Move down-right
            grid[pos.r][pos.c] = NONE;
            pos.r++;
            pos.c++;
            grid[pos.r][pos.c] = SURVIVOR;
            valid_step_found = true;
        }
        if (step_dir == 6 &amp;&amp; pos.r-1 &gt;= 0 &amp;&amp; pos.c-1 &gt;= 0 &amp;&amp; cell_int(pos.r-1, pos.c-1) == NONE) { // Move up-left
            grid[pos.r][pos.c] = NONE;
            pos.r--;
            pos.c--;
            grid[pos.r][pos.c] = SURVIVOR;
            valid_step_found = true;
        }
        if (step_dir == 7 &amp;&amp; pos.r-1 &gt;= 0 &amp;&amp; pos.c+1 &lt; GRID_LENGTH &amp;&amp; cell_int(pos.r-1, pos.c+1) == NONE) { // Move up-right
            grid[pos.r][pos.c] = NONE;
            pos.r--;
            pos.c++;
            grid[pos.r][pos.c] = SURVIVOR;
            valid_step_found = true;
        }
        step_dir = (step_dir+1) % 8;
        if (valid_step_found == false) {
            tries++;
        }
    }

    status = computeStatus(pos.r, pos.c);
    
    if (status == DANGER) grid[pos.r][pos.c] = NEED_ASSIST;

    pos_civilians[id] = pos;
}

/*
 * Step function, update status, global grid and global civilians array
 */
/*
void step(int direction){
    pos_t next_cell;
    pos_t ret_pos = OUT_OF_MAP;
    //pos_t exit_cell = exits[getCloserExit(pos)];

    //getNextCellToGoTo(pos, exit_cell, ret_pos);
    //next_cell = ret_pos;
    next_cell= randomPos(direction, pos);
    
    
    // Check if next_cell is free
    if (isCellFree(next_cell)) {
        move_civ(pos, next_cell);
        pos = next_cell;
    }
    //think about the corner case where a civilian remain stuck in the same cell forever
    
    // Update status
    status = computeStatus(pos.r, pos.c);

    if (status == DANGER) grid[pos.r][pos.c] = NEED_ASSIST;

    pos_civilians[id] = pos;
}
*/

/*
 * Compute Zero Responder time needed to assist a civilian in danger
 */
void computeTimeToAssist() {
    // Calculate the time needed to reach the person in danger.
    timeToAssist = dist2(pos, pos_to_save) + T_ZR;
}

/*
 * Civilian dies
 */
void casualtyOccurred() {
    grid[pos.r][pos.c] = NONE;
    pos.r = -1;
    pos.c = -1;
    pos_civilians[id] = pos;
    status = DEAD;
    casualties++;
}

/*
 * Civilian is safe
 */
void safeOccurred() {
    grid[pos.r][pos.c] = NONE;
    pos.r = -1;
    pos.c = -1;
    pos_civilians[id] = pos;
    status = SAVED;
    saved++;
}
/*
 * Enter the map at the entry point.
 */
void enter() {
    id = p_id;
    pos.r = pos_civilians[id].r;
    pos.c = pos_civilians[id].c;
    status = computeStatus(pos.r, pos.c);
    if (status == DANGER) grid[pos.r][pos.c] = NEED_ASSIST;
}

/*
 * Get civilian in danger id
 */
void getCivInNeed(){
    civ_need_id = get_civ_idx(pos_to_save);
}

/*
 * Civilian start helping (ZR case)
 */
void zrOccurred(){
    x = 0;
    computeTimeToAssist();
    status = ZERO_RESP;
    grid[pos.r][pos.c] = ZERO_R;
    pos_to_save = OUT_OF_MAP;
}

/*
 * Get closer first responder
 */
int getCloserFR(pos_t pos){
    pos_t fr_pos;
    int i, fr_id = -1, min_dist = MAX_INT;
    for(i = 0; i &lt; N_FIRST_RESPONDERS; i++){
        if(dist(pos, pos_FRs[i]) &lt; min_dist &amp;&amp; grid[pos_FRs[i].r][pos_FRs[i].c] == FIRST_R){
            fr_id = i;
            min_dist = dist(pos, pos_FRs[i]);
        }
    }
    return fr_id;
}

/*
 * Civilian instructed to call FR
 */
void frOccurred(){
    fr_id = getCloserFR(pos);
    civ_need_id = get_civ_idx(pos_to_save);
    status = BUSY;
    grid[pos.r][pos.c] = CONTACTING; 
}

/*
 * Civilian gets help
 */
void helpingOccurred(){
    status = CIV_ASSISTED;
    grid[pos.r][pos.c] = ASSISTED;
}

/*
 * Civilian dies before it's saved
 */
void extCasualtyOccurred(){
    x=0;
    status = STEP;
    grid[pos.r][pos.c] = 3;
}</declaration>
		<location id="id13" x="-671" y="-68">
		</location>
		<location id="id14" x="-144" y="-68">
			<name x="-127" y="-85">Danger</name>
			<label kind="invariant" x="-127" y="-68">x&lt;=T_V</label>
		</location>
		<location id="id15" x="-144" y="187">
			<name x="-195" y="187">Safe</name>
		</location>
		<location id="id16" x="-144" y="-323">
			<name x="-204" y="-365">Moving</name>
			<label kind="invariant" x="-255" y="-348">x&lt;=STEP_TIME</label>
		</location>
		<location id="id17" x="314" y="-323">
			<name x="339" y="-348">Helping</name>
			<label kind="invariant" x="339" y="-323">x&lt;=timeToAssist</label>
		</location>
		<location id="id18" x="-442" y="-68">
			<committed/>
		</location>
		<location id="id19" x="-348" y="59">
			<name x="-399" y="59">Dead</name>
		</location>
		<location id="id20" x="544" y="-484">
			<name x="561" y="-501">Contacting</name>
		</location>
		<location id="id21" x="-144" y="59">
			<name x="-127" y="42">Helped</name>
			<label kind="invariant" x="-127" y="59">x&lt;=T_V</label>
		</location>
		<location id="id22" x="85" y="-323">
			<committed/>
		</location>
		<location id="id23" x="306" y="-484">
			<committed/>
		</location>
		<location id="id24" x="-144" y="-187">
			<committed/>
		</location>
		<init ref="id13"/>
		<transition id="id25">
			<source ref="id24"/>
			<target ref="id16"/>
			<label kind="guard" x="-110" y="-263">status == STEP</label>
			<nail x="-119" y="-255"/>
		</transition>
		<transition id="id26">
			<source ref="id23"/>
			<target ref="id20"/>
			<label kind="synchronisation" x="340" y="-510">FR_help_req[fr_id]!</label>
		</transition>
		<transition id="id27">
			<source ref="id21"/>
			<target ref="id15"/>
			<label kind="synchronisation" x="-314" y="136">saved_by_FR[id]?</label>
			<label kind="assignment" x="-297" y="153">safeOccurred()</label>
			<nail x="-170" y="127"/>
		</transition>
		<transition id="id28">
			<source ref="id22"/>
			<target ref="id17"/>
			<label kind="synchronisation" x="110" y="-348">helping[civ_need_id]!</label>
			<label kind="assignment" x="136" y="-323">zrOccurred()</label>
		</transition>
		<transition id="id29">
			<source ref="id16"/>
			<target ref="id22"/>
			<label kind="synchronisation" x="-102" y="-340">call_zero_resp[id]?</label>
			<label kind="assignment" x="-85" y="-323">getCivInNeed()</label>
		</transition>
		<transition id="id30">
			<source ref="id21"/>
			<target ref="id19"/>
			<label kind="guard" x="-280" y="59">x==T_V</label>
			<label kind="synchronisation" x="-306" y="76">civ_dead[id]!</label>
			<label kind="assignment" x="-331" y="93">casualtyOccurred()</label>
		</transition>
		<transition id="id31">
			<source ref="id14"/>
			<target ref="id21"/>
			<label kind="synchronisation" x="-102" y="-25">helping[id]?</label>
			<label kind="assignment" x="-127" y="-8">helpingOccurred()</label>
		</transition>
		<transition id="id32">
			<source ref="id20"/>
			<target ref="id16"/>
			<label kind="synchronisation" x="119" y="-603">civ_dead[civ_need_id]?</label>
			<label kind="assignment" x="119" y="-578">extCasualtyOccurred()</label>
			<nail x="544" y="-577"/>
			<nail x="-144" y="-578"/>
		</transition>
		<transition id="id33">
			<source ref="id20"/>
			<target ref="id15"/>
			<label kind="synchronisation" x="552" y="9">saved_by_FR[civ_need_id]?</label>
			<label kind="assignment" x="552" y="34">safeOccurred()</label>
			<nail x="544" y="187"/>
		</transition>
		<transition id="id34">
			<source ref="id16"/>
			<target ref="id23"/>
			<label kind="synchronisation" x="59" y="-510">call_first_resp[id]?</label>
			<label kind="assignment" x="93" y="-484">frOccurred()</label>
			<nail x="-25" y="-484"/>
		</transition>
		<transition id="id35">
			<source ref="id17"/>
			<target ref="id16"/>
			<label kind="synchronisation" x="119" y="-433">civ_dead[civ_need_id]?</label>
			<label kind="assignment" x="119" y="-407">extCasualtyOccurred()</label>
			<nail x="314" y="-407"/>
			<nail x="76" y="-408"/>
		</transition>
		<transition id="id36">
			<source ref="id14"/>
			<target ref="id19"/>
			<label kind="guard" x="-357" y="-42">x==T_V</label>
			<label kind="synchronisation" x="-382" y="-25">civ_dead[id]!</label>
			<label kind="assignment" x="-416" y="-8">casualtyOccurred()</label>
		</transition>
		<transition id="id37">
			<source ref="id17"/>
			<target ref="id15"/>
			<label kind="guard" x="323" y="-17">x==timeToAssist</label>
			<label kind="synchronisation" x="323" y="9">saved_by_ZR[civ_need_id]!</label>
			<label kind="assignment" x="323" y="34">safeOccurred()</label>
			<nail x="315" y="187"/>
		</transition>
		<transition id="id38">
			<source ref="id18"/>
			<target ref="id15"/>
			<label kind="guard" x="-578" y="51">status == SAVED</label>
			<label kind="assignment" x="-569" y="76">safeOccurred()</label>
			<nail x="-442" y="187"/>
		</transition>
		<transition id="id39">
			<source ref="id18"/>
			<target ref="id14"/>
			<label kind="guard" x="-357" y="-93">status == DANGER</label>
		</transition>
		<transition id="id40">
			<source ref="id18"/>
			<target ref="id16"/>
			<label kind="guard" x="-570" y="-306">status == STEP</label>
			<nail x="-442" y="-323"/>
		</transition>
		<transition id="id41">
			<source ref="id13"/>
			<target ref="id18"/>
			<label kind="synchronisation" x="-646" y="-93">init_done?</label>
			<label kind="assignment" x="-646" y="-68">enter()</label>
		</transition>
		<transition id="id42">
			<source ref="id24"/>
			<target ref="id14"/>
			<label kind="guard" x="-136" y="-153">status == DANGER</label>
			<label kind="assignment" x="-85" y="-136">x=0</label>
		</transition>
		<transition id="id43">
			<source ref="id16"/>
			<target ref="id24"/>
			<label kind="select" x="-340" y="-280">direction: int[0, 7]</label>
			<label kind="guard" x="-306" y="-263">x==STEP_TIME</label>
			<label kind="assignment" x="-340" y="-246">step(direction), x=0</label>
			<nail x="-170" y="-255"/>
		</transition>
		<transition id="id44">
			<source ref="id24"/>
			<target ref="id15"/>
			<label kind="guard" x="93" y="-17">status == SAVED</label>
			<label kind="assignment" x="93" y="9">safeOccurred()</label>
			<nail x="85" y="-187"/>
			<nail x="85" y="187"/>
		</transition>
		<transition id="id45">
			<source ref="id21"/>
			<target ref="id15"/>
			<label kind="synchronisation" x="-110" y="136">saved_by_ZR[id]?</label>
			<label kind="assignment" x="-102" y="153">safeOccurred()</label>
			<nail x="-119" y="127"/>
		</transition>
	</template>
	<template>
		<name>Initializer</name>
		<declaration>/*
 * Build exits global array
 */
void build_exits() {
    int i, j, idx = 0;
    for(i=0; i &lt; GRID_LENGTH; i++){
        for(j=0; j &lt; GRID_HEIGHT; j++){
            if(cell_int(i, j) == EXIT){
                exits[idx].r = i;
                exits[idx].c = j;
                idx++;
            }
        }
    }
}

/*
 * Build fires global array
 */
void build_fires() {
    int i, j, idx = 0;
    for(i=0; i &lt; GRID_LENGTH; i++){
        for(j=0; j &lt; GRID_HEIGHT; j++){
            if(cell_int(i, j) == FIRE){
                fires[idx].r = i;
                fires[idx].c = j;
                idx++;
            }
        }
    }
}

/*
 * Build FRs global array
 */
void set_FR_pos() {
    int i, j, idx = 0;
    for(i=0; i &lt; GRID_LENGTH; i++){
        for(j=0; j &lt; GRID_HEIGHT; j++){
            if(cell_int(i, j) == FIRST_R){
                pos_FRs[idx].r = i;
                pos_FRs[idx].c = j;
                idx++;
            }
        }
    }
}

/*
 * Compute trajectory lenghts
 */
void compute_traj_lengths(){
    int i, j;
    pos_t init_pos, curr_pos;
    for(i = 0; i &lt; N_DRONES; i++){
        init_pos = drone_trajectories[i][0];
        curr_pos = drone_trajectories[i][1];
        for(j = 1; j &lt; MAX_TRAJ; j++){
            if(curr_pos == init_pos){
                drone_traj_lengths[i] = j;
                j = MAX_TRAJ; // break
            } else {
                curr_pos = drone_trajectories[i][j];  
            }
        }
    }
}

/*
 * Build civilians global array
 */
void set_civ_pos(){
    int i, j, idx = 0;
    for(i=0; i &lt; GRID_LENGTH; i++){
        for(j=0; j &lt; GRID_HEIGHT; j++){
            if(cell_int(i, j) == SURVIVOR || cell_int(i, j) == NEED_ASSIST){
                pos_civilians[idx].r = i;
                pos_civilians[idx].c = j;
                idx++;
            }
        }
    }
}

void init_all() {
    build_exits();
    set_FR_pos();
    set_civ_pos();
    compute_traj_lengths();
}</declaration>
		<location id="id46" x="-357" y="-76">
			<committed/>
		</location>
		<location id="id47" x="-221" y="-76">
		</location>
		<init ref="id46"/>
		<transition id="id48">
			<source ref="id46"/>
			<target ref="id47"/>
			<label kind="synchronisation" x="-339" y="-93">init_done!</label>
			<label kind="assignment" x="-339" y="-76">init_all()</label>
		</transition>
	</template>
	<template>
		<name x="9" y="9">Drone</name>
		<parameter>dr_t p_id</parameter>
		<declaration>const int STEP = 1;
const int DRONE_ZERO_R = 2;
const int DRONE_FIRST_R = 3;

clock x;
int id;                                // Id
pos_t trajectory[MAX_TRAJ];            // Trajectory            
int traj_l;                            // Trajectory Length            
int k = 0;                             // Trajectory index               
int status = STEP;                     // Status
pos_t pos;                             // Position
int zr;                                // ZeroResponder 

// TODO: check the right status even when entering in the map
// TODO: bug when signaling zr and two in need in range

/*
 * Enter the map at the entry point.
 */
void enter() {
    id = p_id;
    trajectory = drone_trajectories[id];
    pos = trajectory[k];
    k = 0;
    traj_l = drone_traj_lengths[id];
}

/*
 * Check if a civilian in danger is in drone sight and return its position
 */
pos_t civilianInDangerInRange(){
    int i, j;
    pos_t ret_pos = {-1, -1};
    for(i = -N_V; i &lt;= N_V; i++){
        for(j = -N_V; j &lt;= N_V; j++){
            pos_t pos = trajectory[k];
            if (cell_int(pos.r + i, pos.c + j) == NEED_ASSIST){
                pos_t ret_pos = {pos.r + i, pos.c + j};
                return ret_pos;
            }
        }
    }
    return ret_pos;
}

/*
 * Check if a zero responder is in drone sight and return its position
 */
pos_t zeroResponderInRange(){
    int i, j;
    pos_t ret_pos = {-1, -1};
    for(i = -N_V; i &lt;= N_V; i++){
        for(j = -N_V; j &lt;= N_V; j++){
            pos_t pos = trajectory[k];
            if (cell_int(pos.r + i, pos.c + j) == SURVIVOR){
                pos_t ret_pos = {pos.r + i, pos.c + j};
                return ret_pos;
            }
        }
    }
    return ret_pos;
}

/*
 * Decide to ask for direct help or to call first responder
 */
void decisionPolicy() {
    int dec, i, count = 0;
    for(i = 0; i &lt; N_FIRST_RESPONDERS; i++){
        if(cell(pos_FRs[i]) == FIRST_R){
            count++;
        }
    }
    if(count == 0){
        dec = 0;
    }else{
        dec = 1;
        // TODO: write the policy (this, random or minimum time needed to save)
    }
    if(dec == 0){
        status = DRONE_ZERO_R;
    } 
    else{
        status = DRONE_FIRST_R;
    }
}

// TODO: Change it in order to properly set the pos_to_save
/*
 * Step function that follows a specified trajectory
 */
void step() {
    int decision, i;
    pos_t civ_in_danger, potential_zr;

    // Do one step along the trajectory
    k = (k+1) % traj_l;
    pos = trajectory[k];

    // Explore visibility range
    civ_in_danger = civilianInDangerInRange();
    potential_zr = zeroResponderInRange();

    // Find id of the civilian to call (either as a zr either to call a fr)
    zr = get_civ_idx(potential_zr);
    if (civ_in_danger != OUT_OF_MAP &amp;&amp; potential_zr != OUT_OF_MAP) {
        pos_to_save = civ_in_danger;
        decisionPolicy();
    }
}</declaration>
		<location id="id49" x="-1045" y="-76">
		</location>
		<location id="id50" x="-765" y="-76">
			<name x="-833" y="-102">Moving</name>
			<label kind="invariant" x="-884" y="-68">x&lt;=STEP_TIME</label>
		</location>
		<location id="id51" x="-544" y="-76">
			<committed/>
		</location>
		<init ref="id49"/>
		<transition id="id52">
			<source ref="id51"/>
			<target ref="id50"/>
			<label kind="guard" x="-739" y="42">status == DRONE_FIRST_R</label>
			<label kind="synchronisation" x="-731" y="59">call_first_resp[zr]!</label>
			<label kind="assignment" x="-705" y="76">status = STEP</label>
			<nail x="-544" y="42"/>
			<nail x="-765" y="42"/>
		</transition>
		<transition id="id53">
			<source ref="id51"/>
			<target ref="id50"/>
			<label kind="guard" x="-714" y="-42">status == STEP</label>
			<nail x="-654" y="-42"/>
		</transition>
		<transition id="id54">
			<source ref="id51"/>
			<target ref="id50"/>
			<label kind="guard" x="-739" y="-246">status == DRONE_ZERO_R</label>
			<label kind="synchronisation" x="-731" y="-229">call_zero_resp[zr]!</label>
			<label kind="assignment" x="-714" y="-212">status = STEP</label>
			<nail x="-544" y="-85"/>
			<nail x="-544" y="-187"/>
			<nail x="-765" y="-187"/>
		</transition>
		<transition id="id55">
			<source ref="id50"/>
			<target ref="id51"/>
			<label kind="guard" x="-714" y="-153">x == STEP_TIME</label>
			<label kind="assignment" x="-714" y="-136">step(), x = 0</label>
			<nail x="-654" y="-110"/>
		</transition>
		<transition id="id56">
			<source ref="id49"/>
			<target ref="id50"/>
			<label kind="synchronisation" x="-1011" y="-93">init_done?</label>
			<label kind="assignment" x="-1003" y="-76">enter()</label>
		</transition>
	</template>
	<system>//system Initializer, Civilian;

system Initializer, First_Responder, Civilian, Drone;
</system>
	<queries>
		<query>
			<formula/>
			<comment/>
		</query>
	</queries>
</nta>
