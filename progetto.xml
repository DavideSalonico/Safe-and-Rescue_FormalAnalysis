<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.6//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_6.dtd'>
<nta>
	<declaration>// Place global declarations here.
const int GRID_LENGTH = 10;
const int GRID_HEIGHT = 10;
const int N_EXITS = 6;
const int N_FIRES = 7;
const int N_DRONES = 4;
const int N_CIVILIANS = 4;
const int N_FIRST_RESPONDERS = 2;
const int T_ZR = 3;                      // Time that a Zero Responder needs to help someone
const int T_FR = 3;                      // Time that a First Responder needs to help someone
const int STEP_TIME = 1;                 // Time to step
const int T_V = 5;                       // Time before a civilian is supposed to die
const int RANGE = 2;                     // Drones' visibility range

const int MAX_TRAJ = GRID_LENGTH*GRID_HEIGHT/N_DRONES;

// Global types
typedef int [0, N_DRONES-1] bot_t;
typedef int[0, N_FIRST_RESPONDERS - 1] fr_t;
typedef struct { int r; int c; } pos_t;

// Map constants
const int NONE         =  0;
const int EXIT         =  1;             // Exit
const int FIRE         =  2;             // Fire
const int SURVIVOR     =  3;             // Survivor (civilian not in danger)
const int FIRST_R      =  4;             // First Responder not busy
const int FIRST_R_BUSY =  8;             // First Responder busy helping someone
const int ZERO_R       =  5;             // Zero Responder 
const int ASSISTED     =  6;             // Civilian in danger being assisted
const int NEED_ASSIST  =  7;             // Civilian in danger in need for assistance

const pos_t OUT_OF_MAP = {-1, -1};       // Position to declare someone has exited the map (either dead or alive)

const int MAX_INT =  32767; //from doc

// Channels
urgent broadcast chan init_done;
urgent broadcast chan civilian_saved;
urgent broadcast chan helping;
urgent broadcast chan FR_help_req;
urgent broadcast chan saved_by_FR;
broadcast chan saved_by_ZR;
broadcast chan civ_dead;
urgent broadcast chan first_resp;
urgent broadcast chan zero_resp;
urgent broadcast chan call_zero_resp;
urgent broadcast chan call_first_resp;


// Global variables
int casualties = 0;
int saved = 0;

// Grid layout
int grid[GRID_LENGTH][GRID_HEIGHT] = {{0, 0, 1, 1, 1, 0, 0, 0, 0, 0},
                                      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                      {0, 0, 0, 0, 0, 0, 2, 2, 0, 0},
                                      {0, 0, 0, 0, 0, 2, 2, 2, 0, 0},
                                      {0, 0, 0, 0, 0, 2, 2, 0, 0, 0},
                                      {1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                      {1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                      {1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}};

pos_t exits[N_EXITS];

pos_t drone_trajectories[3][2] = {{{1, 1}, {2, 2}},{{3, 3}, {4, 4}}, {{5, 5}, {6, 6}}};

// Global functions


// Exits, Humans, Drones can have arbitrary positions.
pos_t pos_to_save = {-1, -1};

/*
pos_t d_pos1 = {1, 1};
pos_t d_pos2 = {3, 3};
pos_t c_pos1 = {2, 2};
pos_t c_pos2 = {4, 2};

const pos_t DRONE_POS[N_DRONES] = {d_pos1, d_pos2};
const pos_t CIVILIANS_POS[N_CIVILIANS] = {c_pos1, c_pos2};
*/

/* GLOBAL UTILITY FUNCTIONS ****************/

/*
 * Get the value of a cell of the map given its pos_t coordinates.
 */
int cell(pos_t p) {
    return grid[p.r][p.c];
}

/*
 * Get the value of a cell of the map given its int coordinates.
 */
int cell_int(int x, int y) {
    return grid[x][y];
}

/*
 * Check whether a cell of the map is occupied or not.
 */
bool cell_is_free(pos_t p) {
    return cell(p) == NONE;
}

/*
 * Compute distance from two positions in the grid (NO diagonal moves allowed).
 */
int dist2(pos_t src, pos_t dest){
    int x_dist = abs(dest.r - src.r);
    int y_dist = abs(dest.c - src.c);
    return x_dist + y_dist;
}

/*
 * Compute max between two integers.
 */ 
int max(int a, int b){
    return a &gt;= b ? a : b;
}


/*
 * Compute distance from two positions in the grid (diagonal moves allowed).
 */
int dist(pos_t src, pos_t dest){
    int x_dist = abs(dest.r - src.r);
    int y_dist = abs(dest.c - src.c);
    return max(x_dist, y_dist);
}

/*
 * Move civilian from src to dest in the map (when calling the function cell(src) must be SURVIVOR)
 */ 
void move_civ(pos_t src, pos_t dest){
    grid[src.r][src.c] = NONE;
    grid[dest.r][dest.c] = SURVIVOR;
}

/*
 * Move first responder from src to dest in the map (when calling the function cell(src) must be FIRST_R)
 */ 
void move_fr(pos_t src, pos_t dest){
    grid[src.r][src.c] = NONE;
    grid[dest.r][dest.c] = FIRST_R;
}</declaration>
	<template>
		<name>First_Responder</name>
		<parameter>int[0, N_FIRST_RESPONDERS - 1] p_id</parameter>
		<declaration>const int FREE = 0;
const int NEAR_DANGER = 1;
const int CALLED = 2;

clock x;
int id;
pos_t pos;
int status = FREE;

/*
 * Enter the map at the entry point.
 */
void enter() {
    id = p_id;
    pos.r = 1;
    pos.c = 1;
    
    //map[pos.r][pos.c] |= B;
}

// TODO: calcola il tempo per assistere + arrivare se Ã¨ stato contatto
int timeToAssist() {
    if (status == NEAR_DANGER) {
        return T_FR;
    } else {
        return T_FR + 0;//TIME_TO_ARRIVE;  // TODO: capire come calcolare TIME TO ARRIVE
    }
}

bool nearCivilianInDanger() {
    int i, j;
    for (i=-1; i&lt;=1; i++) {
        for (j=-1; j&lt;=1; j++) {
            if (pos.r+i &gt;= 0 &amp;&amp; pos.c+j &gt;= 0 &amp;&amp; pos.r+i &lt; GRID_HEIGHT &amp;&amp; pos.c+j &lt; GRID_LENGTH &amp;&amp; cell_int(pos.r+i, pos.c+j) == NEED_ASSIST)
                return true;
        }
    }
    return false;
}



void step() {
    // Random policy
    bool valid_step_found = false;
    while (valid_step_found == false) {
        int i = fint(random(8));
        if (i == 0 &amp;&amp; pos.r+1 &lt; GRID_HEIGHT &amp;&amp; cell_int(pos.r-1, pos.c) == FREE) { // Move down
            grid[pos.r][pos.c] = NONE;
            pos.r++;
            grid[pos.r][pos.c] = FIRST_R;
            valid_step_found = true;
        }
        if (i == 1 &amp;&amp; pos.r-1 &gt;= 0 &amp;&amp; cell_int(pos.r+1, pos.c) == FREE) { // Move up
            grid[pos.r][pos.c] = NONE;
            pos.r--;
            grid[pos.r][pos.c] = FIRST_R;
            valid_step_found = true;
        }
        if (i == 2 &amp;&amp; pos.c-1 &gt;= 0 &amp;&amp; cell_int(pos.r, pos.c-1) == FREE) { // Move left
            grid[pos.r][pos.c] = NONE;
            pos.c--;
            grid[pos.r][pos.c] = FIRST_R;
            valid_step_found = true;
        }
        if (i == 3 &amp;&amp; pos.c+1 &lt; GRID_LENGTH &amp;&amp; cell_int(pos.r, pos.c+1) == FREE) { // Move right
            grid[pos.r][pos.c] = NONE;
            pos.c++;
            grid[pos.r][pos.c] = FIRST_R;
            valid_step_found = true;
        }
        if (i == 4 &amp;&amp; pos.r+1 &lt; GRID_HEIGHT &amp;&amp; pos.c-1 &gt;= 0 &amp;&amp; cell_int(pos.r-1, pos.c-1) == FREE) { // Move down-left
            grid[pos.r][pos.c] = NONE;
            pos.r++;
            pos.c--;
            grid[pos.r][pos.c] = FIRST_R;
            valid_step_found = true;
        }
        if (i == 5 &amp;&amp; pos.r+1 &lt; GRID_HEIGHT &amp;&amp; pos.c+1 &lt; GRID_LENGTH &amp;&amp; cell_int(pos.r+1, pos.c+1) == FREE) { // Move down-right
            grid[pos.r][pos.c] = NONE;
            pos.r++;
            pos.c++;
            grid[pos.r][pos.c] = FIRST_R;
            valid_step_found = true;
        }
        if (i == 6 &amp;&amp; pos.r-1 &gt;= 0 &amp;&amp; pos.c-1 &gt;= 0 &amp;&amp; cell_int(pos.r-1, pos.c-1) == FREE) { // Move up-left
            grid[pos.r][pos.c] = NONE;
            pos.r--;
            pos.c--;
            grid[pos.r][pos.c] = FIRST_R;
            valid_step_found = true;
        }
        if (i == 7 &amp;&amp; pos.r-1 &gt;= 0 &amp;&amp; pos.c+1 &lt; GRID_LENGTH &amp;&amp; cell_int(pos.r-1, pos.c+1) == FREE) { // Move up-right
            grid[pos.r][pos.c] = NONE;
            pos.r--;
            pos.c++;
            grid[pos.r][pos.c] = FIRST_R;
            valid_step_found = true;
        }
    }

    if (nearCivilianInDanger()) {
        status = NEAR_DANGER;
    }
}

// TODO capire come gestire la precenza tra near danger e la ricezione della richiesta di aiuto
void updateGrid() {
    if (grid[pos.r][pos.c] == FIRST_R) {
        grid[pos.r][pos.c] = FIRST_R_BUSY;
    } else if (grid[pos.r][pos.c] == FIRST_R_BUSY) {
        grid[pos.r][pos.c] = FIRST_R;
    }
}</declaration>
		<location id="id0" x="-620" y="-42">
		</location>
		<location id="id1" x="-476" y="-42">
			<name x="-535" y="-17">Moving</name>
		</location>
		<location id="id2" x="263" y="-42">
			<name x="255" y="-76">Helped</name>
		</location>
		<location id="id3" x="0" y="-42">
			<name x="-25" y="-85">Helping</name>
		</location>
		<location id="id4" x="-238" y="-42">
			<committed/>
		</location>
		<init ref="id0"/>
		<transition id="id5">
			<source ref="id4"/>
			<target ref="id3"/>
			<label kind="synchronisation" x="-170" y="-59">helping!</label>
			<label kind="assignment" x="-153" y="-42">x=0</label>
		</transition>
		<transition id="id6">
			<source ref="id1"/>
			<target ref="id4"/>
			<label kind="synchronisation" x="-408" y="-59">FR_help_req?</label>
			<label kind="assignment" x="-416" y="-42">status=CALLED,
updateGrid()</label>
		</transition>
		<transition id="id7">
			<source ref="id1"/>
			<target ref="id3"/>
			<label kind="guard" x="-323" y="-195">status == NEAR_DANGER</label>
			<label kind="synchronisation" x="-272" y="-178">helping!</label>
			<label kind="assignment" x="-263" y="-161">x = 0</label>
			<nail x="-238" y="-136"/>
		</transition>
		<transition id="id8">
			<source ref="id1"/>
			<target ref="id1"/>
			<label kind="guard" x="-535" y="-178">status == FREE</label>
			<label kind="assignment" x="-501" y="-161">step()</label>
			<nail x="-518" y="-127"/>
			<nail x="-442" y="-127"/>
		</transition>
		<transition id="id9">
			<source ref="id3"/>
			<target ref="id2"/>
			<label kind="guard" x="59" y="-68">x &gt;= timeToAssist()</label>
		</transition>
		<transition id="id10">
			<source ref="id2"/>
			<target ref="id1"/>
			<label kind="synchronisation" x="-161" y="17">saved_by_FR!</label>
			<label kind="assignment" x="-161" y="51">status = FREE,
updateGrid()</label>
			<nail x="263" y="43"/>
			<nail x="-476" y="43"/>
		</transition>
		<transition id="id11">
			<source ref="id0"/>
			<target ref="id1"/>
			<label kind="synchronisation" x="-595" y="-59">init_done?</label>
			<label kind="assignment" x="-586" y="-42">enter()</label>
			<nail x="-493" y="-42"/>
		</transition>
	</template>
	<template>
		<name>Civilian</name>
		<parameter>int p_id, pos_t p_pos</parameter>
		<declaration>const int SAVED = 1;
const int DANGER = 2;
const int STEP = 3;
const int ZERO_RESP = 4;
const int ASSISTED = 5;
const int DEAD = 6;

int id;
clock x;
pos_t pos;
int status = 0;
int timeToAssist = -1;


int getCloserExit(pos_t pos){
    int i, min = MAX_INT;
    int closer_exit = -1;
    for(i=0; i &lt; N_EXITS; i++){
        if(dist(exits[i], pos) &lt; min){
            min = dist(exits[i], pos);
            closer_exit = i;
        }
    }

    return closer_exit;
}

/*
 * Check whether a cell of the map is occupied or not.
 */
bool isCellFreeCiv(pos_t p) {
    if (cell(p) == NONE || cell(p) == EXIT){
        return true;
    }else{
        return false;
    }
}

int computeStatus(int px, int py){
     // check Exit
    int i, j;
    for(i = -1; i &lt; 2; i++){
        for(j = -1; j &lt; 2; j++){
            if(cell_int(px + i, py + j) == EXIT) return SAVED;
        }
    }

    // check Fire 
    for(i = -1; i &lt; 2; i++){
        for(j = -1; j &lt; 2; j++){
            if(cell_int(px + i, py + j) == FIRE) return DANGER;
        }
    }
    
    return STEP;
}


void getNextCellToGoTo(pos_t &amp;pos1, pos_t &amp;pos2, pos_t &amp;ret_pos){
    int x_move, y_move;
    if(pos1.r &gt; pos2.r){
        x_move = 1;
    } 
    else if(pos1.r = pos2.r){
        x_move = 0; // No vertical movement
    }
    else{
        x_move = -1;
    }
    
    if(pos1.c &gt; pos2.c){
        y_move = 1;
    } 
    else if(pos1.c = pos2.c){
        y_move = 0; // No horizontal movement
    }
    else{
        y_move = -1;
    }
   
    ret_pos.r = pos1.r + x_move;
    ret_pos.c = pos1.c + y_move;
}

void step(){
    pos_t next_cell;
    pos_t ret_pos = OUT_OF_MAP;
    pos_t exit_cell = exits[getCloserExit(pos)];

    getNextCellToGoTo(pos, exit_cell, ret_pos);
    next_cell = ret_pos;
    
    // Check if next_cell is free
    if (isCellFreeCiv(next_cell)) {
        move_civ(pos, next_cell);
        pos = next_cell;
    }
    //think about the corner case where a civilian remain stuck in the same cell forever
    
    
    // Update status
    status = computeStatus(pos.r, pos.c);
}


void computeTimeToAssist() {
    // Calculate the time needed to reach the person in danger.
    timeToAssist = dist2(pos, pos_to_save) + T_ZR;
}

void casualtyOccurred() {
    pos.r = -1;
    pos.c = -1;
    status = DEAD;
    casualties++;
}

void safeOccurred() {
    pos.r = -1;
    pos.c = -1;
    status = SAVED;
    saved++;
}
/*
 * Enter the map at the entry point.
 */
void enter() {
    id = p_id;
    pos = p_pos;
    status = computeStatus(pos.r, pos.c);
    //map[pos.r][pos.c] |= B;
}</declaration>
		<location id="id12" x="-756" y="-85">
		</location>
		<location id="id13" x="-144" y="-85">
			<name x="-127" y="-110">Danger</name>
			<label kind="invariant" x="-119" y="-93">x&lt;=T_V</label>
		</location>
		<location id="id14" x="-144" y="195">
			<name x="-195" y="195">Safe</name>
		</location>
		<location id="id15" x="-144" y="-255">
			<name x="-221" y="-255">Moving</name>
			<label kind="invariant" x="-255" y="-238">x&lt;=STEP_TIME</label>
			<label kind="comments" x="-646" y="-382">Controllare se il clock viene inizializzato
a zero dallo stato committed</label>
		</location>
		<location id="id16" x="306" y="-255">
			<name x="331" y="-280">Helping</name>
			<label kind="invariant" x="331" y="-255">x&lt;=timeToAssist</label>
		</location>
		<location id="id17" x="-442" y="-85">
			<committed/>
		</location>
		<location id="id18" x="-348" y="59">
			<name x="-357" y="25">Dead</name>
		</location>
		<location id="id19" x="527" y="-433">
			<name x="544" y="-450">Contacting</name>
		</location>
		<location id="id20" x="-144" y="59">
			<name x="-127" y="34">Helped</name>
			<label kind="invariant" x="-119" y="51">x&lt;=T_V</label>
		</location>
		<location id="id21" x="68" y="-255">
			<committed/>
		</location>
		<init ref="id12"/>
		<transition id="id22">
			<source ref="id20"/>
			<target ref="id14"/>
			<label kind="synchronisation" x="-280" y="153">saved_by_FR?</label>
			<nail x="-178" y="136"/>
		</transition>
		<transition id="id23">
			<source ref="id21"/>
			<target ref="id16"/>
			<label kind="synchronisation" x="136" y="-272">helping!</label>
			<label kind="assignment" x="86" y="-255">x=0, computeTimeToAssist()</label>
		</transition>
		<transition id="id24">
			<source ref="id15"/>
			<target ref="id21"/>
			<label kind="synchronisation" x="-76" y="-272">zero_resp?</label>
		</transition>
		<transition id="id25">
			<source ref="id20"/>
			<target ref="id18"/>
			<label kind="guard" x="-272" y="59">x==T_V</label>
			<label kind="synchronisation" x="-280" y="76">civ_dead!</label>
			<label kind="assignment" x="-323" y="93">casualtyOccurred()</label>
		</transition>
		<transition id="id26">
			<source ref="id13"/>
			<target ref="id20"/>
			<label kind="synchronisation" x="-102" y="-42">helping?</label>
			<label kind="assignment" x="-136" y="-25">status = ASSISTED</label>
		</transition>
		<transition id="id27">
			<source ref="id19"/>
			<target ref="id15"/>
			<label kind="synchronisation" x="93" y="-552">civ_dead?</label>
			<label kind="assignment" x="119" y="-527">x=0</label>
			<nail x="527" y="-526"/>
			<nail x="-59" y="-526"/>
		</transition>
		<transition id="id28">
			<source ref="id19"/>
			<target ref="id14"/>
			<label kind="synchronisation" x="535" y="68">saved_by_FR?</label>
			<label kind="assignment" x="535" y="93">safeOccurred()</label>
			<nail x="527" y="136"/>
			<nail x="527" y="195"/>
		</transition>
		<transition id="id29">
			<source ref="id15"/>
			<target ref="id19"/>
			<label kind="synchronisation" x="93" y="-458">first_resp?</label>
			<nail x="-34" y="-433"/>
		</transition>
		<transition id="id30">
			<source ref="id16"/>
			<target ref="id15"/>
			<label kind="synchronisation" x="127" y="-373">civ_dead?</label>
			<label kind="assignment" x="153" y="-348">x=0</label>
			<nail x="306" y="-348"/>
			<nail x="93" y="-348"/>
		</transition>
		<transition id="id31">
			<source ref="id13"/>
			<target ref="id18"/>
			<label kind="guard" x="-323" y="-42">x==T_V</label>
			<label kind="synchronisation" x="-348" y="-25">civ_dead!</label>
			<label kind="assignment" x="-425" y="-8">casualtyOccurred()</label>
		</transition>
		<transition id="id32">
			<source ref="id16"/>
			<target ref="id14"/>
			<label kind="guard" x="314" y="-34">x==timeToAssist</label>
			<label kind="synchronisation" x="314" y="-8">saved_by_ZR!</label>
			<label kind="assignment" x="314" y="17">safeOccurred()</label>
			<nail x="306" y="195"/>
		</transition>
		<transition id="id33">
			<source ref="id17"/>
			<target ref="id14"/>
			<label kind="guard" x="-578" y="34">status == SAVED</label>
			<label kind="assignment" x="-569" y="59">safeOccurred()</label>
			<nail x="-442" y="195"/>
		</transition>
		<transition id="id34">
			<source ref="id17"/>
			<target ref="id13"/>
			<label kind="guard" x="-357" y="-110">status == DANGER</label>
		</transition>
		<transition id="id35">
			<source ref="id17"/>
			<target ref="id15"/>
			<label kind="guard" x="-570" y="-238">status == STEP</label>
			<nail x="-442" y="-255"/>
		</transition>
		<transition id="id36">
			<source ref="id12"/>
			<target ref="id17"/>
			<label kind="synchronisation" x="-722" y="-110">init_done?</label>
			<label kind="assignment" x="-722" y="-85">enter()</label>
		</transition>
		<transition id="id37">
			<source ref="id15"/>
			<target ref="id13"/>
			<label kind="guard" x="-289" y="-187">status == DANGER</label>
			<label kind="assignment" x="-229" y="-170">x=0</label>
		</transition>
		<transition id="id38">
			<source ref="id15"/>
			<target ref="id15"/>
			<label kind="guard" x="-255" y="-442">x==STEP_TIME</label>
			<label kind="assignment" x="-263" y="-425">step(), x=0</label>
			<nail x="-204" y="-340"/>
			<nail x="-204" y="-391"/>
			<nail x="-144" y="-391"/>
			<nail x="-144" y="-331"/>
			<nail x="-144" y="-331"/>
			<nail x="-144" y="-331"/>
		</transition>
		<transition id="id39">
			<source ref="id15"/>
			<target ref="id14"/>
			<label kind="guard" x="93" y="-68">status == SAVED</label>
			<label kind="assignment" x="93" y="-42">safeOccurred()</label>
			<nail x="85" y="-85"/>
			<nail x="85" y="195"/>
		</transition>
		<transition id="id40">
			<source ref="id20"/>
			<target ref="id14"/>
			<label kind="synchronisation" x="-102" y="153">saved_by_ZR?</label>
			<nail x="-110" y="136"/>
		</transition>
	</template>
	<template>
		<name>Initializer</name>
		<declaration>void build_exits(){
    int i, j, idx = 0;
    for(i=0; i &lt; GRID_LENGTH; i++){
        for(j=0; j &lt; GRID_HEIGHT; j++){
            if(cell_int(i, j) == EXIT){
                exits[idx].r = i;
                exits[idx].c = j;
                idx++;
            }
        }
    }
}

void init_all() {
    build_exits();
}</declaration>
		<location id="id41" x="-357" y="-76">
			<committed/>
		</location>
		<location id="id42" x="-221" y="-76">
		</location>
		<init ref="id41"/>
		<transition id="id43">
			<source ref="id41"/>
			<target ref="id42"/>
			<label kind="synchronisation" x="-339" y="-93">init_done!</label>
			<label kind="assignment" x="-339" y="-76">init_all()</label>
		</transition>
	</template>
	<template>
		<name x="9" y="9">Drone</name>
		<parameter>int p_id, int traj_length</parameter>
		<declaration>const int STEP = 1;
const int ZERO_R = 2;
const int FIRST_R = 3;

urgent chan call_zero_respond;
urgent chan call_first_respond;

clock clk;
int id;
pos_t trajectory[2];
int traj_l;
int k = 0;
int status = STEP;
pos_t pos;

/*
 * Enter the map at the entry point.
 */
void enter() {
    k = 0;
    id = p_id;
    trajectory = drone_trajectories[p_id];
    pos = trajectory[k];
    traj_l = traj_length;
}


// The following two methods should be updated in order to return the exact location of the located entity so that the distance is faster to compute
pos_t civilianInDangerInRange(){
    int i, j;
    pos_t ret_pos = {-1, -1};
    for(i = -RANGE; i &lt;= RANGE; i++){
        for(j = -RANGE; j &lt;= RANGE; j++){
            pos_t pos = trajectory[k];
            if (cell_int(pos.r + i, pos.c + j) == NEED_ASSIST){
                pos_t ret_pos = {pos.r + i, pos.c + j};
                return ret_pos;
            }
           
        }
    }
    return ret_pos;
}

pos_t zeroResponderInRange(){
    int i, j;
    pos_t ret_pos = {-1, -1};
    for(i = -RANGE; i &lt;= RANGE; i++){
        for(j = -RANGE; j &lt;= RANGE; j++){
            pos_t pos = trajectory[k];
            if (cell_int(pos.r + i, pos.c + j) == ZERO_R){
                pos_t ret_pos = {pos.r + i, pos.c + j};
                return ret_pos;
            }
        }
    }
    return ret_pos;
}

void decisionPolicy() {
    int dec = fint(random(2));
    if(dec == 0){
        status = ZERO_R;
    } 
    else{
        status = FIRST_R;
    }
}

void step() {
    pos_t tmp_pos;
    k = (k+1 % traj_l);
    tmp_pos = trajectory[k];
    pos = tmp_pos;
    if (civilianInDangerInRange() != OUT_OF_MAP &amp;&amp; zeroResponderInRange() != OUT_OF_MAP) {
        decisionPolicy();
    }
}</declaration>
		<location id="id44" x="-1045" y="-76">
		</location>
		<location id="id45" x="-765" y="-76">
			<name x="-850" y="-68">Moving</name>
		</location>
		<location id="id46" x="-765" y="-246">
			<name x="-816" y="-280">ZeroRespFound</name>
			<committed/>
		</location>
		<location id="id47" x="-765" y="94">
			<name x="-824" y="111">FirstRespContact</name>
			<committed/>
		</location>
		<init ref="id44"/>
		<transition id="id48">
			<source ref="id45"/>
			<target ref="id45"/>
			<label kind="guard" x="-663" y="-93">status == STEP</label>
			<label kind="assignment" x="-629" y="-76">step()</label>
			<nail x="-671" y="-110"/>
			<nail x="-671" y="-42"/>
		</transition>
		<transition id="id49">
			<source ref="id45"/>
			<target ref="id47"/>
			<label kind="guard" x="-960" y="0">status == FIRST_R</label>
			<nail x="-807" y="9"/>
		</transition>
		<transition id="id50">
			<source ref="id45"/>
			<target ref="id46"/>
			<label kind="guard" x="-952" y="-178">status == ZERO_R</label>
			<nail x="-807" y="-162"/>
		</transition>
		<transition id="id51">
			<source ref="id47"/>
			<target ref="id45"/>
			<label kind="synchronisation" x="-714" y="-8">call_first_resp!</label>
			<label kind="assignment" x="-705" y="8">status = STEP</label>
			<nail x="-722" y="9"/>
		</transition>
		<transition id="id52">
			<source ref="id46"/>
			<target ref="id45"/>
			<label kind="synchronisation" x="-714" y="-178">call_zero_resp!</label>
			<label kind="assignment" x="-714" y="-161">status = STEP</label>
			<nail x="-722" y="-162"/>
		</transition>
		<transition id="id53">
			<source ref="id44"/>
			<target ref="id45"/>
			<label kind="synchronisation" x="-1011" y="-93">init_done?</label>
			<label kind="assignment" x="-1003" y="-76">enter()</label>
		</transition>
	</template>
	<system>// Place template instantiations here.
initializer = Initializer();

// List one or more processes to be composed into a system.
system initializer /*, Drone, Civilian*/, First_Responder;
</system>
	<queries>
		<query>
			<formula/>
			<comment/>
		</query>
	</queries>
</nta>
